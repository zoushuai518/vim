" rubbish  && fuck~~~
" last modify 2014-08-04 end
"
" ubuntu 平台 vim7.3
" zs config enable
"
" All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just
" /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime
" you can find below.  If you wish to change any of those settings, you should
" do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten
" everytime an upgrade of the vim packages is performed.  It is recommended to
" make changes after sourcing debian.vim since it alters the value of the
" 'compatible' option.

" This line should not be removed as it ensures that various options are
" properly set to work with the Vim-related packages available in Debian.
runtime! debian.vim

" Uncomment the next line to make Vim more Vi-compatible
" NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
" options, so any other options should be set AFTER setting 'compatible'.
"set compatible

" Vim5 and later versions support syntax highlighting. Uncommenting the next
" line enables syntax highlighting by default.
if has("syntax")
	syntax on
endif

" If using a dark background within the editing area and syntax highlighting
" turn on this option as well
"set background=dark

" Uncomment the following to have Vim jump to the last position when
" reopening a file
"if has("autocmd")
"  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
"endif

" Uncomment the following to have Vim load indentation rules and plugins
" according to the detected filetype.
"if has("autocmd")
"  filetype plugin indent on
"endif

" The following are commented out as they cause vim to behave a lot
" differently from regular Vi. They are highly recommended though.
"set showcmd		" Show (partial) command in status line.
"set showmatch		" Show matching brackets.
"set ignorecase		" Do case insensitive matching
"set smartcase		" Do smart case matching
"set incsearch		" Incremental search
"set autowrite		" Automatically save before commands like :next and :make
"set hidden             " Hide buffers when they are abandoned
"set mouse=a		" Enable mouse usage (all modes)

" Source a global configuration file if available
if filereadable("/etc/vim/vimrc.local")
	source /etc/vim/vimrc.local
endif


"zs config 注
"
"use: gg=:1,$ Enter 文件代码格式化

" 以下VIM配置,参考 pan.baidu.com 中的 zs_ubuntu压缩包中的;vim_ide文件夹

"常用变量
"$VIMRUNTIME
"$VIM : vim的安装的根目录.	[ad: ubuntu /usr/share/vim]
"
":echo $VIM
":ehco $VIMRUNTIME
":scriptname
"
":version
":scriptnames


"zs config

"base config s
set tabstop=4			"设定tab宽度为4个字符
set softtabstop=4
set shiftwidth=4		"设定自动缩进为4个字符
"set noexpandtab        "不用space替代tab的输入
"set expandtab			"用space替代tab的输入 [需要输入真正的Tab键时，使用 Ctrl+V + Tab]
"%ret! 4				"每个tab用4个space替代
set autoindent
"set number

" 相对行号      行号变成相对，可以用 nj  nk   进行跳转 5j   5k 上下跳5行
set relativenumber number
au FocusLost * :set norelativenumber number
au FocusGained * :set relativenumber
" 插入模式下用绝对行号, 普通模式下用相对
autocmd InsertEnter * :set norelativenumber number
autocmd InsertLeave * :set relativenumber
function! NumberToggle()
  if(&relativenumber == 1)
    set norelativenumber number
  else
    set relativenumber
  endif
endfunc
nnoremap <C-n> :call NumberToggle()<cr>
" 在上下移动光标时，光标的上方或下方至少会保留显示的行数
set scrolloff=7


"命令行提示有关设置 zs
set wildmenu
set showcmd		"当我们输入命令时就会在屏幕的下部显示出部分命令

set nobackup
"set bg=dark		"显示不同的底色色调
set wrap        "自动折行


" 设置编码
" set enc=utf-8
" " 设置文件编码
" set fenc=utf-8
" " 设置文件编码检测类型及支持格式
" set fencs=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
" " 指定菜单语言
" set langmenu=zh_CN.UTF-8
" "解决consle输出乱码
" language messages zh_CN.utf-8
" "解决菜单乱码
" source $VIMRUNTIME/delmenu.vim
" source $VIMRUNTIME/menu.vim
set fileencoding=utf8  "默认文件编码
set fileencodings==utf8,gbk,cp936  "可以识别的文件编码;需要Linux系统支持中文方可

"打开文件都会显示^M符号
set fileformats=unix,dos
"转换文件换行方式
"解决方法：设置fileformat属性，:set ff=dos (\r\n win换行) :set ff=unix (\n unix/linux换行) :set ff=mac (\r Mac换行)
":set fileformats=unix,dos


"设置字体大小
"set guifont=Courier\\23		"在Linux种这样设置

" 中文帮助
" if version > 603
" set helplang=cn
" endif
"
"设置粘贴模式，这样粘贴过来的程序代码就不会错位了。zs注,很有用
"set paste


" 显示括号配对情况
set showmatch
" 自动缩进4空格
set cindent shiftwidth=4
" 智能自动缩进
set smartindent
" 设置自动缩进
set ai!


"显示光标的状态行
set guioptions-=T
""隐藏左、右侧滚动条
set guioptions-=r
set guioptions-=L


" 单行注释
" set comments=://
" " 段落注释
" set comments=s1:/*,mb:*,ex0:/

"与windows共享剪贴板
"set clipboard+=unnamed
"


"vim 中设置 tab 空格 等特殊字符 zs dev s
"
"配置:
"set list
"set listchars=tab:▸\ ,eol:-

" 显示 空格|TAB
" 命令行输入:
" :set list listchars=tab:>-,trail:-
"
"vim 中设置 tab 空格 等特殊字符 zs dev e

"
" 显示tab和空格   zs测试可用
" http://zshou.is-programmer.com/posts/39381
set list
" 设置tab和空格样式
set lcs=tab:\|\ ,nbsp:%,trail:-
" 设定行首tab为灰色
highlight LeaderTab guifg=#666666
" 匹配行首tab
match LeaderTab /^\t/

" 设定行尾tab为灰色 没效果
"highlight EndTab guifg=#666666
" 匹配行尾tab 没效果
"match EndTab /^\t/

"上面的设置将Tab显示为|(竖线)，将行尾的空格显示为-(减号)
"
":set list | :set nolist
" 显示tab和空格   zs测试可用

"在一般的情况下,list命令使用^I来表示Tab而使用$来表示一行的结尾.我们也可以自定义这种形为.我们可以使用listchars选项来定义list模式如何工作.这个命令的格式如下:
":set listchars=key:string,key:string
"而key:string可以用到的值如下:
"eol:{char} 定义放在一行结尾处的字符
"tab:{char1}{char2} 一个Tab值为char1和char2的组合来表示.
"trail:{char} 用来表示结尾空格的字符.
"extends:{char} 用来表示一行的结尾和下一行连接的字符
"我们可以使用highlight选项来改变许多对象的高亮显示.这个选项的格式如下:
":set highlight=key:group,[key:group]...
"我们可以使用下面的key值:
"key Default Meaning
"8 SpeicalKey 当用:map命令列出特殊键时用来高亮显示
"@ NonText Vim用~和@来表示不在缓冲区中的内容时适用.
"M Modemsg 在屏幕下部显示的模式信息.
"S StatusLineNC 除当前窗口外的每一个窗口的状态行.
"V VisualNOS 可视化模式下选择的文本.
"w WildMenu 作为通配符的一部分而显示
"d Directroy 当我们按下CTRL-D时显示的目录
"e ErrorMsg 错误信息.
"i IncSearch 作为增量查找的一部分而显示
"I Search 作来查找的一部分而显示
"m MoreMsg --More--提示
"n LineNr 由命令:number打印出的行号
"r Question 按下回车的提示及其他的问题
"s StatusLine 当前窗口的状态行
"t Title 输入信息的命令标题.
"v Visual 在可视化模式下选择的文本
"w WaringMsg 警告信息.
"我们还可以使用缩写字符:
"r Reverse
"i Italic
"b Bold
"s Standout
"u Underline
"n None
"- None
"所以我们可以通过下面的命令来使用ErrorMsg组来高亮显示错误信息:
":set highlight=e:ErrorMsg
"或者我们可以通过下面的命令来以reverse,bold,italic方式来显示错误:
":set highlight=ervb
"如果我们设置了more选项,当一个命令的显示会超出一屏时就会显示More提示.如果没有进行设置只是会翻滚屏幕.默认如下:
":set more
"下面的命令定义了可以由CTRL-A,CTRL-X识别的数字格式.
":set nrformats=octal,hex
"(注:十进制总是可以识别)
"如果我们设置了下面的选项,Vim就会试着重新装入终端屏幕的内容.
":set restorescreen
"换句话说,他会试着使得我们运行这个程序以后的屏幕看起来就像他运行以前的一样.
"xterm可以允许我们按下鼠标左键拉动时选择文本.这个文本可以粘贴到其他的窗口中.然后一些由于兼容的问题会使得我们在粘贴文本时出现问题.为了避免这样的问题,我们可以使用下面的命令来设置粘贴模式:
":set paste
"然而有时我们希望是粘贴模式而有时希望不是.pastetoggle选项可以使得我们定义一个键在这两种模式中进行切换.例如,如果我们使用F12键进行切换,我们可以用下面的命令:
":set pastetoggle=<F12>
"当关闭粘贴模式时,所以的选项就会恢复到先前的值.
"当我们在ex模式下输入命令时,我们可以实现文件名的自动完成.例如如果我们想要读入文件input.txt,我们可以输入下面的命令:
":read input<Tab>
"Vim就会试着猜出我们想要的文件.如果在我们当前的目录下只有文件input.txt,他就会显示出如下的形式:
":read input.txt
"如果在当前目录下有几个带有input的文件名,则会显示第一个.如果我们再按下Tab,就会显示出第二个相匹配的结果,再按下Tab就会显示第三个.
"我们可以通过下面的命令来定义完成通配符的键:
":set wildchar=character



"
"vim打开时窗口设置默认大小
"lines是上下宽度,以行为单位
"columns是左右宽度,以字符个数为单位
"所以这句设置就是打开时为上下35行宽,左右118个字符宽的窗口
"set lines=35 columns=118


"设置标尺
set ruler               " 在编辑过程中，在右下角显示光标位置的状态行
set showmode            "屏幕的下部显示出我们当前所处的状态
"高亮显示当前行
set cursorline
"hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
"高亮显示当前列
set cursorcolumn

"hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
" cursor
"set cursorline
"hi CursorLine ctermbg=lightgray cterm=NONE
"set cursorcolumn
"hi CursorColumn ctermbg=lightgray
"
"如果我们要定义我们自己的标尺格式,我们可以用下面的命令:
":set rulerformat=string
"这里的string就是我们在statusline选项用到的.
"当我们删除或是修改了一些行的文本,如果这些行数超出了report所指定的行数,Vim编辑器就会告诉这一些情况.所以如果我们要Vim报告所有的变化,我们可以用下面的命令:
":set report=0
"相反,如果我们不希望Vim来告诉我们这些变化,我们可以将这个值设成一个相当大的值就可了.

"base config e
"


"ext config s

" history文件中需要记录的行数
set history=100
" 在处理未保存或只读文件的时候，弹出确认
set confirm


"在一般的情况下,当我们执行了:shell命令时Vim就会警告我们文件已修改.如果我们要关闭这个选项,我们可以执行下面的命令:
":set nowarn
"当Vim捕获一个错误时,他只是会显示出一个错误信息.如果我们要打开声音警告我们可以执行下面的命令:
":set errorbells
"但是有时这样的设置会影响我们的其他的同事,在这样的情况下我们可以来设置visualbell选项.这样当我们输入错误时屏幕就会闪动然后回到正常状态.要设置这样的选项我们可以执行下面的命令:
":set visualbell


"set mouse=a		" Enable mouse usage (all modes)

" 语法高亮
syntax enable
"开启文件类型侦测
syntax on
" 针对不同的文件类型采用不同的缩进格式
filetype indent on
" 针对不同的文件类型加载对应的插件
filetype plugin on
" 启用插件
filetype plugin indent on


" 自定义状态行,显示
" 参考 line 1558	" PowerLine插件,会使 set statusline设置失效
" set cmdheight=1	" 设定命令行的行数为 1
set laststatus=2	" 显示状态栏 (默认值为 1, 无法显示状态栏)
"状态行显示的内容（包括文件类型和解码） 
"set statusline=%F%m%r%h%w%=\[共%L行][%l,%v][%p%%]\%{strftime(\"%d/%m/%y\ -\ %H:%M\")}

":set statusline=format
"%用来指明一个特殊的区域.例如%f来告诉Vim在状行中包含文件名.如下面的命令:
":set statusline=The/ file/ is//"%f/"
"这时的状态行为:
"The file is "sample.txt"
"我们可以指定一个内容的最大和最小的宽度.例如下面的命令告诉Vim编辑器文件至少为8个字符但是最多为19个字符.这些内容是右对齐的,如果我们希望他们能左对齐,我们可以在%后面加上-.数字的内容是忽略开头的0来显示.如果我们需要我们可以在%后加上一个0.例如我们要显示列数而需要开始的0,我们可以使用下面的命令:
":set statusline=%05.10c
"格式,类型以及描述如下:
"%(...%) 定义一个项目组.如果在这个组中的所有的内容均为空,整个组的内容就不会显示.
"%{n}* %对其余的行使用高亮显示组Usern,直到看到另一个%n*.格式%0*会使得行成为正常的高亮显示.如果高亮显示组User1带有下划线(:set statusline=File:/%1*%f%0).这时状态行显示的文件名就会带有下划线.
"%< 如果状态行过长，在何处换行。缺省是在开头
"%= 定义在一行中部的某处.所有向左的字符串放在这行的左部,而向右的字符串放在一行中靠近右边的部.
"% 字符%
"%B 光标下字符的十六进制形式
"%F 全路径的文件名
"%H 如果为帮助缓冲区则为HLP
"%L 缓冲区中的行数.
"%M 如果缓冲区修改过则显示为+
"%O 以十六进制方式显示文件中的字符偏移
"%P 文件中光标前的%
"%R 如果缓冲区只读则为RO
"%V 列数.如果与%c相同则为空字符串
"%W 如果窗口为预览窗口则为PRV
"%Y 文件类型
"a%(字符串) 如果我们在编辑多行文本,这个字行串就是"({current} of
"{arguments})".例如:(5 of 18).如果在命令行中只有一行,这个字符串为空.
"%b(数字) 光标下的字符的十进制表示形式.
"%c(数字) 列号
"%f(字符串) 在命令行中指定的文件名
"%h(标记) 如果为帮助缓冲区为[Help]
"%l(数字) 行号
"%m(标记) 如果缓冲区已修改则表示为+
"%n(数字) 缓冲区号
"%o(数字) 在光标前的字符数,包括光标下的字符
"%p(数字) 文件中所在行的百分比
"%r(标记) 如果缓冲区为只读则表示为RO
"%t(字符串) 文件名(无路径)
"%v(数字) 虚列号
"%w(标记) 如果为预览窗口则显示为Preview
"%y(标记) 我们输入的文件类型
"%{expr%} 表达式的结果
"标记的内容会被特殊的对待.多行标记,例如RO和PRV,则会自动的由逗号来分隔.而例如+和help则会由空格来分隔.例如:
":set statusline=%h%m%r


"search config s
"输入搜索内容时就显示搜索结果
set incsearch
set nohls
"搜索结果高亮显示
set hlsearch
"用nh去掉查找后的高亮 zs注 :noh是vim的命令;可以参考这个配置来配置其它vim命令的快捷键
nmap nh :noh<cr>
set ofu=syntaxcomplete#Complete
"搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感
set ignorecase smartcase
"search config e


" vim 代码折叠设置 s

"zs use
set fdm=indent
set autochdir				 " 自动切换当前目录为当前文件所在的目录


"set foldenable              " 开始折叠
"set foldmethod=syntax       " 设置语法折叠
"set foldcolumn=0            " 设置折叠区域的宽度
"setlocal foldlevel=1        " 设置折叠层数为
"set foldclose=all           " 设置为自动关闭折叠
"nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>		" 用空格键来开关折叠


" 打开javascript折叠
" javascript.vim 语法高亮
" ~/.vim/syntax/javascript.vim
let b:javascript_fold=1		"一般javascript编程，折叠层数不需要太深，我自己设置为1
" 打开javascript对dom、html和css的支持
let javascript_enable_domhtmlcss=1

" vim 代码折叠设置 e


"""""""
"VIM判断 操作系统 类型
"return OS type, eg: windows, or linux, mac, et.st..
"function! MySys()
"	if has("win16") || has("win32") || has("win64") || has("win95")
"		return "windows"
"	elseif has("unix")
"		return "linux"
"	endif
"endfunction

" 用户目录变量$VIMFILES
"if MySys() == "windows"
"   let $VIMFILES = $VIM.'/vimfiles'
"elseif MySys() == "linux"
"   let $VIMFILES = $HOME.'/.vim'
"endif

"设定doc文档目录
"let helptags=$VIMFILES.'/doc'


""""""""""""""""""""'
"F2处理行尾的空格以及文件尾部的多余空行
" zs 测试可用;暂时隐藏

" s
""Automatically remove trailing spaces when saving a file.
"autocmd BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif
""Remove indenting on empty line
"map <F2> :w<CR>:call CleanupBuffer(1)<CR>:noh<CR>
"function! CleanupBuffer(keep)
"	" Skip binary files
"	if (&bin > 0)
"		return
"	endif
"	" Remove spaces and tabs from end of every line, if possible
"	silent! %s/\s\+$//ge
"	" Save current line number
"	let lnum = line(".")
"	" number of last line
"	let lastline = line("$")
"	let n        = lastline
"	" while loop
"	while (1)
"		" content of last line
"		let line = getline(n)
"		" remove spaces and tab
"		if (!empty(line))
"			break
"		endif
"		let n = n - 1
"	endwhile
"	" Delete all empty lines at the end of file
"	let start = n+1+a:keep
"	if (start < lastline)
"		execute n+1+a:keep . "," . lastline . "d"
"	endif
"	" after clean spaces and tabs, jump back
"	exec "normal " . lnum . "G"
"endfunction
" e


" 高亮指定的列
" zs测试可用
" set cc=80
" set colorcolumn=80
map ch :set cc=150<CR>
"按下,ch就可以将当前光标下的列高亮
map nch :set cc=0<CR>
"按下,nch取消列高亮

"配合 vim Indent Guides 垂直对其插件
let g:indent_guides_guide_size=1
"zs注：vim7.3以后版本,不需要此插件。直接设置 ruler即可,见 line 201行设置


"zs 测试不可用
"map ch :call SetColorColumn()<CR>
"function! SetColorColumn()
"	let col_num = virtcol(".")
"	let cc_list = split(&cc, '')
"	if count(cc_list, string(col_num)) <= 0
"		execute "set cc+=".col_num
"	else
"		execute "set cc-=".col_num
"	endif
"endfunction
"按下,ch就可以将当前光标下的列高亮，再按下一次，取消高亮；并且可以同时多列高亮



"vim配置文件中的nnoremap和inoremap有什么区别:
"一个是在普通模式(normal mode)下生效的映射，一个是在插入模式(insert mode)下生效。
"这样可以在不同模式下使用同一个按键产生不同的效果。
"noremap 和 map 的区别是，被映射的序列不会再被递归映射))
"
"vim自动补全括号、引号 s
inoremap ( ()<ESC>i
inoremap ), (),<ESC>hi
inoremap ); ();<ESC>hi

inoremap [ []<ESC>i
inoremap ], [],<ESC>hi
inoremap ]; [];<ESC>hi

inoremap { {}<ESC>i
inoremap < <><ESC>i
inoremap " ""<ESC>i
inoremap ", "",<ESC>hi
inoremap "; "";<ESC>hi
inoremap ' ''<ESC>i
inoremap ', '',<ESC>hi
inoremap '; '';<ESC>hi
""可以写一个函数手动用call调用:
"function MyCompleteAdd()
"	inoremap ( ()<ESC>i
"	inoremap [ []<ESC>i
"	inoremap { {}<ESC>i
"	inoremap < <><ESC>i
"	inoremap " ""<ESC>i
"	inoremap ' ''<ESC>i
"endfunction
"function MyCompleteDel()
"	noremap ( (
"	inoremap [ [
"	inoremap { {
"	inoremap < <
"	inoremap " "
"	inoremap ' '
"endfunction
"vim自动补全括号、引号 e

""""""""""""""""""""'


"zs 注 vim 绑定快捷键 s
"
"zs use s
"Alt快捷键定义方式 : Alt+o
"map <A-o> <ESC>:bp<CR>
"Ctrl快捷键定义方式 : Ctrl+o
"map <C-o> <ESC>:bp<CR>
"Shift快捷键定义方式 : Shift+o
"map <S-o> <ESC>:bp<CR>
"zs use e
"
"适用于普通模式的映射命令有：
"1. :map 
"[语法] :map {lhs} {rhs} |mapmode-nvo| *:map* 
"1.1 作用模式： n、v、o （普通、可视和选择、操作符等待） 
"1.2 命令格式： 
":map {lhs} {rhs} 
"含义： 在:map作用的模式中把键系列 {lhs} 映射为
"{rhs}，{rhs}可进行映射扫描，也就是可递归映射。 
"1.3 举例： 
":map td :tabnew .<cr> 
"含义：在其作用模式（普通、可视、操作符）下，输入td等价于输入 :tabnew .
"<cr>。而普通模式下输入:tabnew . <cr>就是打开当前目录 
"如果再定义绑定 :map ts
"td，就是指在其作用模式下输入ts等价于td，也就是打开当前目录。不过如果没有特殊需要，一般不建议递归映射。 
"
"zs 注 vim 绑定快捷键 e
"

" zs 配置快捷键
"
" 垂直增加10宽度
map vr+ :vertical resize +10<CR>
" 垂直减少10宽度
map vr- :vertical resize -10<CR>
" 水平增加10宽度
map r+  :resize +10<CR>
" 水平减少10宽度
map r-  :resize -10<CR>
"
"开启行号
map nu :set nu<CR>
"关闭行号
map nnu :set nonu<CR>

" 保存当前窗口
map s :w<CR>
" 保存当前窗口
map sq :wq<CR>
" 保存当前窗口
map sa :wqa<CR>

" 不保存退出当前窗口
map qq :q!<CR>
" 不保存打开的所有窗口
map qa :qa!<CR>
" Ctrl + v = Esc

" 退到 linux终端
map shl :sh<CR>

" 关闭方向键, 强迫自己用 hjkl
map <Left> <Nop>
map <Right> <Nop>
map <Up> <Nop>
map <Down> <Nop>

"zs ext注:
"
":set ic设置搜索时忽略大小写 
":set noic搜索时对大小写敏感 
":set list显示不可视字符 
":set nolist不显示不可视字符 
":set showmode显示当前操作模式 
":set shownomode不显示当前操作模式 
":set显示所有的vi环境变量设置 
":set all显示所有的vi环境变量可能取值及其当前设置值 
"你也可以把这些操作放在home目录下你创建的文件.exec中，set操作放在该文件中，不用带前面的：，一行一个命令，一旦该文件存在时，每次你开启一个vi会话时系统将取读取该文件来设置对应的vi环境变量
"

"ext config e



" plugin config s

"color theme s		|zzz
"
"ubuntu 需要使用 solarized.sh脚本, dir:~/zs_ubuntu/vim_ide/solarized.sh
"
"一般的Linux发行版默认的终端都是16色的，但事实上几乎所有的终端都支持256色终端
"1.将Terminal设为Xterm模式:编辑->配置文件首选项->颜色
"设置为自定义,内置方案选择XTerm.
"2.vimrc里设置：set t_Co=256
"
"syntax enable
if has('gui_running')
	set background=light
else
	"set background=dark
    set guifont=Monaco:h14
    set guioptions-=T
    set guioptions+=e
    set guioptions-=r
    set guioptions-=L
    set guitablabel=%M\ %t
    set showtabline=1
    set linespace=2
    set noimd
    set t_Co=256
endif
set background=dark
colorscheme solarized
"set t_Co=16		"需要添加,否则会出现 文字 有阴影的情况
set t_Co=256
" 增强显示配置
let g:solarized_termtrans=1
let g:solarized_contrast="normal"
let g:solarized_visibility="normal"
"
"colorscheme desert
"color theme e
"
"" for error highlight，防止错误整行标红导致看不清
highlight clear SpellBad
highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
highlight clear SpellCap
highlight SpellCap term=underline cterm=underline
highlight clear SpellRare
highlight SpellRare term=underline cterm=underline
highlight clear SpellLocal
highlight SpellLocal term=underline cterm=underline

""""""

"javascript		|zz
"javascript ide s
"
"javascript dict
autocmd FileType javascript set dictionary=~/.vim/dict/javascript.dict
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
":set omnifunc=javascriptcomplete#CompleteJS
"
"javascript ide e



"php ide s


"colorscheme peachpuff

"php缩进
let PHP_autoformatcomment=1
"
" Enable enhanced command line completion.
set wildmenu wildmode=list:full
" Ignore these filenames during enhanced command line completion.
set wildignore+=*.aux,*.out,*.toc " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif " binary images
set wildignore+=*.luac " Lua byte code
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.pyc " Python byte code
set wildignore+=*.spl " compiled spelling word lists
set wildignore+=*.sw? " Vim swap files
"
"
" You might also find this useful
" PHP Generated Code Highlights (HTML & SQL)
" let php_sql_query=1
" let php_htmlInStrings=1
" let g:php_folding=2
" set foldmethod=syntax
"
"
" syntax enable
" source ~/.vim/syntax/php.vim
"

"php complete|Autocomplete|vim php autocomplete s
"
"一、如何安装phpcomplete插件
"如果是VIM7.0以上，不需要再下载 phpcomplete.vim 这个插件，因为安装时自带了，在目录/usr/share/vim/vim73/autoload/phpcomplete.vim中。
""在 ~/.vimrc 中添加这样两行：
"filetype plugin on
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
set ofu=syntaxcomplete#Complete
"#只有在是PHP文件时，才启用PHP补全
"
"php complete e


"php 中 一般是会在 "$", "->", "::" 后需要出现自动补全，在 .vimrc 中加入以下代码：
if !exists('g:AutoComplPop_Behavior')
	let g:AutoComplPop_Behavior = {}
	let g:AutoComplPop_Behavior['php'] = []
	call add(g:AutoComplPop_Behavior['php'], {
				\   'command'   : "\<C-x>\<C-o>",
				\   'pattern'   : printf('\(->\|::\|\$\)\k\{%d,}$', 0),
				\   'repeat'    : 0,
				\})
endif


"php 函数字典	|zzz
"php 函数字典 s

"autocmd FileType php set dictionary+=~/.vim/php_funclist.dict
"autocmd FileType php set complete+=~/.vim/php_funclist.dict

"""""""""

"set dictionary-=/usr/share/vim/dict/php.dict dictionary+=/usr/share/vim/dict/php.dict
" 设置自动完成的监听方式：尾部添加一个字母和清除一个字母
"set complete-=k complete+=k

" 智能Tab补全的代码，它会根据上下文自动选择补全模式：
"inoremap <tab> <c-r>=Smart_TabComplete()<CR>
"function! Smart_TabComplete()
"  let line = getline('.')                         " current line
"
"  let substr = strpart(line, -1, col('.')+1)      " from the start of the current
"                                                  " line to one character right
"                                                  " of the cursor
"  let substr = matchstr(substr, "[^ \t]*$")       " word till cursor
"  if (strlen(substr)==0)                          " nothing to match on empty string
"    return "\<tab>"
"  endif
"  let has_period = match(substr, '\.') != -1      " position of period, if any
"  let has_slash = match(substr, '\/') != -1       " position of slash, if any
"  if (!has_period && !has_slash)
"    return "\<C-X>\<C-P>"                         " existing text matching
"  elseif ( has_slash )
"    return "\<C-X>\<C-F>"                         " file matching
"  else
"    return "\<C-X>\<C-O>"                         " plugin matching
"  endif
"endfunction

""""""""""

"设置字典自动完成
set complete+=k
"设置字典
set dictionary=~/.vim/php_funclist.dict
"" 自动完成使用TAB键
"This function determines, wether we are on
""the start of the line text(then tab indents)
"or if we want to try auto completion
function! InsertTabWrapper()
	let col=col('.')-1
	if !col || getline('.')[col-1] !~ '\k'
		return "\<TAB>"
	else
		return "\<C-N>"
	endif
endfunction
"使用SuperTab之后，就可以关闭该设置了
inoremap <TAB> <C-R>=InsertTabWrapper()<CR>

"php 函数字典 e


"quickfix s
"vim7.3 已经集成此插件,无需另外安装
"set makeprg=php\ -ln\ %
"set errorformat=%m\ in\ %f\ on\ line\ %l
"nmap <f9> :sil! make<cr>:cwindow<cr>

" php quickfix
" zs 测试可用
" 639
setlocal makeprg=php\ -ln\ %
setlocal errorformat=%m\ in\ %f\ on\ line\ %l
"nmap <buffer> <f9> :sil! make<cr>:cwindow<cr>
nmap <buffer> <C-p> :sil! make<cr>:cwindow<cr>

" javascript |nodejs quickfix
" zs 测试可用
""sudo apt-get install npm
""sudo npm -g install jslint
"set makeprg=jslint\ %
"set errorformat=%-P%f,
"        \%E%>\ #%n\ %m,%Z%.%#Line\ %l\\,\ Pos\ %c,
"        \%-G%f\ is\ OK.,%-Q
"":make
"nmap <buffer> <C-j> :sil! make<cr>:cwindow<cr>
"quickfix e


"phpdocumentor插件 s
"
"http://www.vim.org/scripts/script.php?script_id=1355
"下载php-doc.vim
"cp ./php-doc.vim /usr/share/vim/vim73/autoload/php-doc.vim
"
"如何使用：
"在函数定义出注释按ctrl+p即可
"
"source ~/.vim/php-doc.vim
"inoremap <C-P> <ESC>:call PhpDocSingle()<CR>i
"nnoremap <C-P> :call PhpDocSingle()<CR> 
"vnoremap <C-P> :call PhpDocRange()<CR>
"
"phpdocumentor插件 e
"
" run file with PHP CLI (CTRL-M)
" :autocmd FileType php noremap <C-M> :w!<CR>:!/usr/bin/php %<CR>
"
" PHP parser check (CTRL-L)
" :autocmd FileType php noremap <C-L> :!/usr/bin/php -l %<CR>
"
" Do use the currently active spell checking for completion though!
" (I love this feature :-)
" set complete+=kspell


" assistant.vim		|zzz
" assistant.vim s
" php语法增强插件
"
"assistant.vim文件 配置 assistant支持的语言
"let s:aType = {}
"let s:aType = { 
"|             \'php':'php', 'phps':'php', 'phtml':'php',
"|   |   |     \'vim':'vim', 'vimrc':'vim'
"|   |   |     \}  
 
"打开 assistant.vim文件 查看如何使用 assistant插件
"Description:  1. Display the definition of functions, variables, etc(<C-k>).
"|   |   |     2. Complete keywords(<C-x><C-u>).
"Description:提示 使用 Ctrl + k , Ctrl + x , Ctrl + u快捷键
"
"assistant.vim e


"Autocompletition s

"Autocompletition e


"php 语法检查	|z
"zs 测试中
" 见559行 quickfix
"
"function! CheckSyntax()
"	if &filetype!="php"
"		echohl WarningMsg | echo "Fail to check syntax! Please select the right file!" | echohl None
"		return
"	endif
"	if &filetype=="php"
"		setlocal makeprg=\"php\"\ -l\ -n\ -d\ html_errors=off
"		setlocal shellpipe=>
"		setlocal errorformat=%m\ in\ %f\ on\ line\ %l
"	endif
"	execute "silent make %"
"	set makeprg=make
"	execute "normal :"
"	execute "copen"
"endfunction
""map <F7> :call CheckSyntax()<CR>
"map cs :call CheckSyntax()<CR>


" php ide ext s

"php code_sniffer,php-md. phpqa.vim s	|z
"zs 测试中
"
"php code_sniffer 默认安装目录:/usr/bin/phpcs
"php mess Detector 默认安装目录:/usr/bin/phpmd

"let g:phpqa_codesniffer_args = "--standard=Zend"
"let g:phpqa_codesniffer_cmd  = '/usr/bin/phpcs'
"let g:phpqa_codesniffer_autorun = 1        "default =1 on save
"let g:phpqa_messdetector_ruleset = ''
"let g:phpqa_messdetector_cmd = '/usr/bin/phpmd'
"let g:phpqa_messdetector_autorun = 0

"zs use
"在 linux终端执行
":!php -l % 这个是检查当前php文件语法参数
"
"phpcs -h
":phpcs 这个就是code sniffer了
"
":phpmd  这个是mess detector , 需要一个XML规则文件如果没有设置
"
":phpcc  这个显示code coverage. 也需要一个XML规则文件如果没有设置
"

"ext:
"
"php code_sniffer
"参数里面的 --standard=Zend 意思是codesniffer采用Zend的编码风格来效验。
"你可以自定义一些效验规则， 这个规则在debian里面
"/usr/share/php/PHP/CodeSniffer/Standards/ 
"里面，你可以把自定义的放进去。然后把
"let g:phpqa_codesniffer_args = "--standard=Zend"
"改为
"let g:phpqa_codesniffer_args = "--standard=自定义的"
"就可以使用自定义的代码风格效验了.

"php code_sniffer,php-md. phpqa.vim e


"phpcpd s
"PHP Copy Paste Detector(https://github.com/sebastianbergmann/phpcpd)
"顾名思义，检查冗余代码的

"phpcpd e

"phpdcd s
"PHP Dead Code Detector(https://github.com/sebastianbergmann/phpdcd)
"看名字就知道了，检查从未被调用过的方法

"phpdcd s



"Vim + Xdebug + DBGp
"xdebug | Vdebug	|z
"vim DBGp client s
"
"设置dbgp客户端要监听的端口号		|注意：要与xdebug.ini中端口配置一致
"let g:debuggerPort = 9000
let g:debuggerPort = 9001
"为了能看到php数组的值，还需要设置下.vimrc
let g:debuggerMaxDepth = 5

"zs use
":Bp		"设置断点

"dbgp 快捷键
"vim DBGP快捷键和 ubuntu系统快捷键冲突,解决:
"自定义配置 示例来自  debugger.vim文件
"map <F1> :python debugger_resize()<cr>
"map <F2> :python debugger_command('step_into')<cr>
"map <F3> :python debugger_command('step_over')<cr>
"map <F4> :python debugger_command('step_out')<cr>
"
"map <Leader>dr :python debugger_resize()<cr>
"map <Leader>di :python debugger_command('step_into')<cr>
"map <Leader>do :python debugger_command('step_over')<cr>
"map <Leader>dt :python debugger_command('step_out')<cr>
"
"nnoremap ,e :python debugger_watch_input("eval")<cr>A
"
"map <F5> :python debugger_run()<cr>
"map <F6> :python debugger_quit()<cr>
"
"map <F7> :python debugger_command('step_into')<cr>
"map <F8> :python debugger_command('step_over')<cr>
"map <F9> :python debugger_command('step_out')<cr>
"
"map <F11> :python debugger_context()<cr>
"map <F12> :python debugger_property()<cr>
"map <F11> :python debugger_watch_input("context_get")<cr>A<cr>
"map <F12> :python debugger_watch_input("property_get", '<cword>')<cr>A<cr>
"
"hi DbgCurrent term=reverse ctermfg=White ctermbg=Red gui=reverse
"hi DbgBreakPt term=reverse ctermfg=White ctermbg=Green gui=reverse
"
"command! -nargs=? Bp python debugger_mark('<args>')
"command! -nargs=0 Up python debugger_up()
"command! -nargs=0 Dn python debugger_down()
"sign define current text=->  texthl=DbgCurrent linehl=DbgCurrent
"sign define breakpt text=B>  texthl=DbgBreakPt linehl=DbgBreakPt
"....

"RADME DBGP
"因为窗口不大，那4个小窗口只有watch_window对我有用，所以可以直接修改debugger.py，把对应窗口的代码都注视掉，只留下watch_window，这样watch_window就独占右侧了
"
"minibufexplorer 插件,在执行 DBGP调试的时候,会使窗口混乱;尚未找到解决方法
"vim 设置折叠,在进行 DBGP调试的时候,也不是很友好,可以设置 vim打开文件默认不开启折叠

"vim DBGP config s
"There are some variables that you can configure in Vim:
"
"g:debuggerPort [9000]
"The port that the plugin will use to receive the connections from the
"debugger
"g:debuggerProxyHost [localhost]
"Host where the proxy is
"g:debuggerProxyPort
"Port used to connect to the proxy, leave it unset if not using proxy
"g:debuggerProxyKey
"Key used in the connection with the proxy
"g:debuggerMaxChildren [32]
"TODO
"g:debuggerMaxData [32]
"TODO
"g:debuggerMaxChildren [1024]
"TODO
"g:debuggerMaxDepth [1]
"Maximum depth level when dumping variables
"g:debuggerMiniBufExpl [0]
"TODO
"g:debuggerFileMapping [[]]
"Array with pairs of regular expressions to match and replacement strings,
"e,g: [['/var/www/[^/]+/(.*)', '/home/' . $USER . '/project/\\1']]
"vim DBGP config e

"vim DBGp client e


"vim php debug README s
"vim DBGP|[xdebug]
"vim php调试

"PHP Mess Detector(http://phpmd.org/)
"PHP项目体检工具，根据你设定的标准（如单一文件代码体积，未使用的参数个数，未使用的方法数）检查PHP代码，超出设定的标准时报警。

"PHP Copy Paste Detector(https://github.com/sebastianbergmann/phpcpd)
"顾名思义，检查冗余代码的

"PHP Dead Code Detector(https://github.com/sebastianbergmann/phpdcd)
"看名字就知道了，检查从未被调用过的方法

"PHP Code Sniffer(http://pear.php.net/package/PHP_CodeSniffer)
"老牌代码格式化工具，PHP写的，Pear包，可自己hack，可集成到命令行里。

"Code Beautifier，只有Windows GUI，Windows CMD很难用，已经打算跳槽到PHP CS了
"你还可以用jenkins把上述工具以plugins形式整合起来，做持续集成：http://jenkins-php.org/
"你还可以用xinc+phing跟上述工具集成起来做持续集成后的自动化打包发布：http://code.google.com/p/xinc/

"PHPLint http://www.icosaedro.it/phplint/
"vim php debug README e

" php ide ext e


"php ide e


"html自动补全	|zz
"html自动补全 s
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
"html自动补全 e


"html_autoclosetag.vim	|z
"html_autoclosetag.vim s
"html自动输入匹配标签，输入>之后自动完成匹配标签
"au FileType xhtml,xml so ~/.vim/ftplugin/html_autoclosetag.vim
"html_autoclosetag.vim e


"MiniBufExplorer	|zzzz
"多文件编辑 s
""MiniBufExplorer
let g:miniBufExplMapWindowsNavVim=1		"可以用<C-h,j,k,l>切换到上下左右的窗口中去
let g:miniBufExplMapWindowNavArrows=1		"用<C-箭头键>切换到上下左右窗口中去
let g:miniBufExplMapCTabSwitchWindows=1

"<C-Tab> 向前循环切换到每个buffer上,并在但前窗口打开
"<C-S-Tab> 向后循环切换到每个buffer上,并在但前窗口打开
let g:miniBufExplMapCTabSwitchBufs=1

"let g:miniBufExplModSelTarget = 1

"解决FileExplorer窗口变小问题
"let g:bufExplorerMaxHeight=40
"let g:miniBufExplorerMoreThanOne=0		"这个设置保证在打开0个以上的文件是最高限制都是有用的

" MiniBufExpl Colors
"hi MBENormal               guifg=#808080 guibg=fg
"hi MBEChanged              guifg=#CD5907 guibg=fg
"hi MBEVisibleNormal        guifg=#5DC2D6 guibg=fg
"hi MBEVisibleChanged       guifg=#F1266F guibg=fg
"hi MBEVisibleActiveNormal  guifg=#A6DB29 guibg=fg
"hi MBEVisibleActiveChanged guifg=#F1266F guibg=fg

"minibufexplorer其它常用命令
" :MiniBufExplorer  ,mbe   " Open and/or goto Explorer
" :CMiniBufExplorer ,mbc  " Close the Explorer if it's open
" :UMiniBufExplorer ,mbu  " Update Explorer without naviting
" :TMiniBufExplorer ,mbt  " Toggle the Explorer window open and closed
"多文件编辑 e
"Alt + -> 打开下一个文件,zs set
"map <M-right> <ESC>:bn<RETURN>
map <A-right> <ESC>:bn<RETURN>
"Alt + <- 打开上一个文件,zs set
"map <M-left> <ESC>:bp<RETURN>
map <A-left> <ESC>:bp<RETURN>


"NERDTree	|zzz
"NERDTree s
"目录插件
"map <F1> :NERDTreeToggle<CR>
"map <C-F1> :NERDTreeFind<CR>
"let NERDTreeChDirMode=2  "选中root即设置为当前目录
"let NERDTreeQuitOnOpen=1 "打开文件时关闭树
"let NERDTreeShowBookmarks=1 "显示书签
"let NERDTreeMinimalUI=1 "不显示帮助面板
"let NERDTreeDirArrows=1 "目录箭头 1显示箭头  0传统+-|号
"map <F3> :NERDTreeToggle<CR>		"F3快捷键,zs set
"nmap ne :NERDTreeToggle<CR>		"ne快捷键
"NERDTree e



"Trinity	|zzzz
"Trinity s

"集成, NERD_tree,taglist,srcexpl 三个插件
" Open and close all the three plugins on the same time 
"nmap tta  :TrinityToggleAll<CR> 
nmap tta  :TrinityToggleAll<CR> 
" Open and close the Source Explorer separately 
"nmap tts  :TrinityToggleSourceExplorer<CR> 
nmap tts  :TrinityToggleSourceExplorer<CR> 
" Open and close the Taglist separately 
"nmap ttl :TrinityToggleTagList<CR> 
nmap ttl :TrinityToggleTagList<CR> 
" Open and close the NERD Tree separately 
"nmap ttn :TrinityToggleNERDTree<CR> 
nmap ttn :TrinityToggleNERDTree<CR> 

"----

"NERD_Tree s
"NERD_Tree config
"NERD_Tree e

"taglist s
"taglist config
"taglist e

"srcexpl s
"SrcExpl 类比与 Taglist + Ctags 跳转插件
"
"回车跳转到定义的文本，空格跳转回来
"
"zs use
"sudo apt-get install ctags
"cd ./project
"sudo ctags -R *
"先跳到 SrcExpl窗口指定的行 -> 按下<ENTER>跳转到函数处, 按下 <SPACE>跳转回原处
"
"srcexpl config
"
""=================== SrcExpl ==================== 
"zs 测试中:
"nmap <F5> :SrcExplToggle<CR> "快捷键映射 let g:SrcExpl_winHeight = 8 "默认高度 let g:SrcExpl_refreshTime = 100 "更新时间(ms) let g:SrcExpl_isUpdateTags = 0 "每次打开SrcExpl时是否更新tags(0为不更新) let g:SrcExpl_updateTagsKey = "<F12>" "更新tags的快捷键
"
"" // The switch of the Source Explorer 
"nmap <F8> :SrcExplToggle<CR> 
"
"" // Set the height of Source Explorer window 
"let g:SrcExpl_winHeight = 8 
"
"" // Set 100 ms for refreshing the Source Explorer 
"let g:SrcExpl_refreshTime = 100 
"
"" // Set "Enter" key to jump into the exact definition context 
"let g:SrcExpl_jumpKey = "<ENTER>" 
"
"" // Set "Space" key for back from the definition context 
"let g:SrcExpl_gobackKey = "<SPACE>" 
"
"" // In order to avoid conflicts, the Source Explorer should know what plugins
"" // except itself are using buffers. And you need add their buffer names into
"" // below listaccording to the command ":buffers!"
"let g:SrcExpl_pluginList = [ 
"        \ "__Tag_List__", 
"        \ "_NERD_tree_" 
"    \ ] 
"
"" // Enable/Disable the local definition searching, and note that this is not 
"" // guaranteed to work, the Source Explorer doesn't check the syntax for now. 
"" // It only searches for a match with the keyword according to command 'gd' 
"let g:SrcExpl_searchLocalDef = 1 
"
"" // Do not let the Source Explorer update the tags file when opening 
"let g:SrcExpl_isUpdateTags = 0 
"
"" // Use 'Exuberant Ctags' with '--sort=foldcase -R .' or '-L cscope.files' to 
"" // create/update the tags file 
"let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ." 
"
"" // Set "<F12>" key for updating the tags file artificially 
"let g:SrcExpl_updateTagsKey = "<F12>" 
"let g:SrcExpl_updateTagsKey = "<C-s>" 
"
"" // Set "<F3>" key for displaying the previous definition in the jump list 
"let g:SrcExpl_prevDefKey = "<F3>" 
"
"" // Set "<F4>" key for displaying the next definition in the jump list 
"let g:SrcExpl_nextDefKey = "<F4>" 
"srcexpl e

"Trinity e



"neocomplcache		|zzzz
"neocomplcache s
"自动补全插件
let g:neocomplcache_enable_at_startup = 1
"neocomplcache e


"autocomplpop s
"自动补全插件

"autocomplpop e


"DoxygenToolkit		|zz
"DoxygenToolkit s
"生成注释

"doxygen toolkit
let g:DoxygenToolkit_briefTag_pre="Function name "
"let g:DoxygenToolkit_briefTag_post = "<++>"
let g:DoxygenToolkit_paramTag_pre="@Param Param "
let g:DoxygenToolkit_returnTag="@Returns Returns"
"let g:DoxygenToolkit_blockHeader="--------------------------------------------------------------------------"
"let g:DoxygenToolkit_blockFooter="--------------------------------------------------------------------------"
let g:DoxygenToolkit_authorName="weiyan"
let g:DoxygenToolkit_licenseTag="license v"
let g:DoxygenToolkit_authorName="weiyan, weiyan@b5m.com"
let s:licenseTag = "Copyright(C)\<enter>"
let s:licenseTag = s:licenseTag . "For free\<enter>"
let s:licenseTag = s:licenseTag . "All right reserved\<enter>"
let g:DoxygenToolkit_licenseTag = s:licenseTag
let g:DoxygenToolkit_briefTag_funcName = "yes"
"let g:DoxygenToolkit_commentType= "php"
let g:DoxygenToolkit_compactDoc = "yes"
"let g:DoxygenToolkit_throwTag_pre = "yes"
let g:DoxygenToolkit_cinoptions = "no"
let g:doxygen_enhanced_color=1

"F1为添加文件头快捷键
"au FileType cpp map <F1> :DoxAuthor<CR>
"au FileType python map <F1> :DoxAuthor<CR>
"F2为添加函数注释
"au FileType cpp map <F2> :Dox<CR>
"au FileType python map <F2> :Dox<CR>

"" use doxygen 这个工具
"光标在函数上，用 :Dox 自动生成函数的说明
"光标在文件头，用 :DoxAuthor 自动生成文件说明
"用 :DoxLic
"可以结合doxygen自动生成各种格式的文档

"DoxygenToolkit e


" 状态栏颜色配置 s		|zzzz
" 参考 line 354
if version >= 700
	au InsertEnter * hi StatusLine term=reverse ctermbg=5 gui=undercurl guisp=Magenta
	au InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=2 gui=bold,reverse
endif
"插入模式也有很多种派生的状态 s
function! InsertStatuslineColor(mode)
	if a:mode == 'i'
		hi statusline guibg=magenta
	elseif a:mode == 'r'
		hi statusline guibg=blue
	else
		hi statusline guibg=red
	endif
endfunction
au InsertEnter * call InsertStatuslineColor(v:insertmode)
au InsertChange * call InsertStatuslineColor(v:insertmode)
au InsertLeave * hi statusline guibg=green
" default the statusline to green when entering Vim
hi statusline guibg=green

":help InsertEnter
":help InsertChange
":help InsertLeave
":help v:insertmode
":help :hi
":help hl-StatusLine

"插入模式也有很多种派生的状态 e

" 状态栏颜色配置 e


"CTags	|zzzz
"CTags s
""let Tlist_Ctags_Cmd="/usr/share/CTags"		"linux 下 ctags执行文件目录
"let Tlist_Ctags_Cmd="/usr/bin/ctags"		"linux 下 ctags执行文件目录

"Taglist	|zzzz
"Taglist s
""map <silent> <leader>tl :TlistToogle<cr>
"let Tlist_Auto_Highlight_Tag = 1
"let Tlist_Auto_Open = 1
"let Tlist_Auto_Update = 1
"let Tlist_Close_On_Select = 0
"let Tlist_Compact_Format = 0
"let Tlist_Display_Prototype = 0
"let Tlist_Display_Tag_Scope = 1
"let Tlist_Enable_Fold_Column = 0
"let Tlist_Exit_OnlyWindow = 0
"let Tlist_File_Fold_Auto_Close = 0
"let Tlist_GainFocus_On_ToggleOpen = 1
"let Tlist_Hightlight_Tag_On_BufEnter = 1
"let Tlist_Inc_Winwidth = 0
"let Tlist_Use_Right_Window = 1
""map <silent> <leader>tl :TlistToogle<cr>
""map <F4> :TlistToggle<CR>		"F4快捷键,zs set
""map tl :TlistToggle<CR>		"tl快捷键,
"
"let Tlist_Show_One_File = 1            "不同时显示多个文件的tag，只显示当前文件的
"let Tlist_Exit_OnlyWindow = 1          "如果taglist窗口是最后一个窗口，则退出vim
"let Tlist_Use_Right_Window = 1         "在右侧窗口中显示taglist窗口
""map <silent> <F9> :TlistToggle<cr>
"Taglist e

"Ctags 生成的tags文件路径
"set tags=/var/www/html/zixun/tags
" 增强检索功能
"set tags=./tags,./../tags,./**/tags

"""""""""""""""""""""""
""F12生成/更新tags文件
"set tags=tags;
"set autochdir
"function! UpdateTagsFile()
"	silent !ctags -R --fields=+ianS --extra=+q
"endfunction
"nmap <F12> :call UpdateTagsFile()<CR>
"
""Ctrl + F12删除tags文件
"function! DeleteTagsFile()
"	"Linux下的删除方法
"	"silent !rm tags
"	"Windows下的删除方法
"	silent !del /F /Q tags
"endfunction
"nmap <C-F12> :call DeleteTagsFile()<CR>
""退出VIM之前删除tags文件
""au VimLeavePre * call DeleteTagsFile()
"""""""""""""""""""""""
"
"zs use: Ctrl+] || Ctrl+t
"
"CTags e


"vim tab补全插件 s
"SuperTab.vim
"下载 supertab.vim
"sudo cp supertab.vmb /usr/share/vim/vim73/plugin/supertab.vim
"
"config s
"let g:SuperTabRetainCompletionType=2
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"

"以后当你准备按"Ctrl+X Ctrl+O"的时候直接按<Tab>就好了, 够爽吧 ....

"我稍微再介绍一下上面那两句配置信息:
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"
" 设置按下<Tab>后默认的补全方式, 默认是<C-P>,
" " 现在改为<C-X><C-O>. 关于<C-P>的补全方式,
" " 还有其他的补全方式, 你可以看看下面的一些帮助:
" " :help ins-completion
" " :help compl-omni
"
" let g:SuperTabRetainCompletionType=2
" " 0 - 不记录上次的补全方式
" " 1 - 记住上次的补全方式,直到用其他的补全命令改变它
" " 2 - 记住上次的补全方式,直到按ESC退出插入模式为止
"config s
"
"
"""""""""""""""""""""""""""
"vim 中SuperTab的安装和使用
"『插件介绍』
"SuperTab使Tab快捷键具有更快捷的上下文提示功能。
"
"『下载和安装』
"从http://www.vim.org/scripts/script.php?script_id=1643下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。
"    1）用Vim打开.vba安装包文件。
"    2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。
"    3）在~/.vimrc文件中加入以下这行：
"       let g:SuperTabDefaultCompletionType="context"
"
"      『基本功能使用方法』
"      SuperTab使用很简单，只要在输入变量名或路径名等符号中途按Tab键，就能得到以前输入过的符号列表，并通过Tab键循环选择。
"""""""""""""""""""""""""""
"
"vim tab补全插件 e



"snipMate	|zzzz
"snipMate s
"片断补全,可自定义补全片段
"
"重启vim。
"如果还是不可以的话。可以在gvim任意打开一个文件，然后输入以下命令查看vim文件夹路径，并修改第3步中路径参数。
":echo $VIM                <<=================>>          D:/安装目录/Vim
":echo $VIMRUNTIME         <<=================>>	   	D:/安装目录/Vim/vim72
"(按tab快速生成代码段)
"
"let g:snippets_dir='$VIMRUNTIME/snippets'
"let g:snippets_dir='~/.vim/snipMate'
"
"
"////////////////////////////////
"打开vim分别输入以下几行命令
":echo $VIM
":ehco $VIMRUNTIME
":scriptname
"
"前两个会输出vim的路径,我这里的路径为
"/usr/shre/vim/
"/usr/shre/vim/vim73
"第三个会输出vim加载的脚本名,可以看到这里是没有加载/snipMate 的
"filetype plugin on
"
"
"zs 注:
"在 .vimrc里面添加配置
"set runtimepath=/usr/share/vim/vim73,~/vim,~/vim/after
"let g:snippets_dir='~/.vim/snippets'
"注：上述路径是自己的安装目录，根据自己情况进行修改。
"ubuntu直接放在 ~./vim/目录下即可; 很多其它插件可类比
"
"...zs需要研究,vim snipMate的自定义配置方法
"
"snipMate e
"


"Tabular	|zzzz
"vim 赋值[但不限于]符号对齐 s
"Tabular
"有时候我们可能希望我们一段的赋值代码都用=号对齐

"添加 Tabularize映射
let mapleader=','
if exists(":Tabularize")
	nmap <Leader>a= :Tabularize /=<CR>
	vmap <Leader>a= :Tabularize /=<CR>
	nmap <Leader>a: :Tabularize /:\zs<CR>
	vmap <Leader>a: :Tabularize /:\zs<CR>
endif

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a

function! s:align()
	let p = '^\s*|\s.*\s|\s*$'
	if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
		let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
		let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
		Tabularize/|/l1
		normal! 0
		call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
	endif
endfunction

"zs use
"V 选择要对齐的行
"按 : 进入命令模式; 此时命令行会显示 :'<,'>
"输出对齐命令: Tabularize /=
"此时 命令行 如下
":'<,'>Tabularize /=
"直接回车即可 按照 = 对齐
"
"map <F6> :Tabularize /=<CR>		"F6快捷键,zs set
map t= :Tabularize /=<CR>		"t=快捷键,zs set


"解决方法：安装Tabular插件，选中要对齐的代码，输入:Tab/= 让代码通过=两边对齐

"V 选择, 之後在下面繼續打, 都會自動排序. (若文字過長, 上面都會自動對齊)
"
":Tab/ 後面接要分隔的符號, ex: 上述是用 "|" 分隔, 所以輸入 :Tab/|, 程式若要排
""=", 則輸入 :Tab/=, 更多範例可見下述:

":Tab/:
":Tab/=
":Tab/:\zs # 只有排序 ":" 後面的文字

"vim 赋值[但不限于]符号对齐 e


"PowerLine s
" 参考 line 343
"PowerLine是一个增强的Vim状态栏插件 s
"PowerLine是一个增强的Vim状态栏插件。当Vim处于NORMAL、INSERT、BLOCK等状态时，状态栏会呈现不同的颜色，同时状态栏还会显示当前编辑文件的格式（uft-8等）、文件类型（java、xml等）和光标位置等。
"从https://github.com/Lokaltog/vim-powerline下载PowerLine插件，将文件解压得到的autoload、doc、plugin和fontpatcher文件夹放到~/Vim/Vim73/bundler目录下，往_vimrc文件中增加下面配置即可
"
"set laststatus=2
set guifont=PowerlineSymbols\ for\ Powerline
"set guifont=Ubuntu\ Mono\ 12endifelseif
set nocompatible
set t_Co=256
"let g:Powerline_symbols = 'fancy'
let g:Powerline_symbols='unicode'
"set fillchars+=stl:\ ,stlnc:\

"nmap <Leader>r :PowerlineReloadColorscheme<CR>
""autocmd BufWinEnter * call Pl#UpdateStatusline(1)
""autocmd BufWritePost _vimrc call PowerlineReloadColorscheme
"let g:Powerline_mode_n  = 'N'  " Normal (surrounded by spaces)
"let g:Powerline_mode_i  = 'I'  " Insert
"let g:Powerline_mode_R  = 'R'  " Replace
"let g:Powerline_mode_v  = 'v'  " Visual
"let g:Powerline_mode_V  = 'V'  " Visual linewise
"let g:Powerline_mode_cv = 'cv' " Visual blockwise
"let g:Powerline_mode_s  = 's'  " Select
"let g:Powerline_mode_S  = 'S'  " Select linewise
"let g:Powerline_mode_cs = 'cs' " Select blockwise
"配置待研究...

":PowerlineClearCache清理过powerline缓存，而且终端字体也换成了打过补丁的字体了
":help Powerline

"PowerLine e


"日历
"Calendar s		|zz
let g:calendar_diary = "~/diary" " 设置日记的存储路径
let g:calendar_monday = 1 "以星期一为开始
let g:calendar_focus_today = 1 " 光标在当天的日期上
let g:calendar_mark = 'left-fit' "可以让*和数字可靠近
"在vimrc中设置let g:calendar_diary = "~/diary"
"这是设置日记的存放目录，必须自己先建立这个目录。
""打开vim，用:Calendar 或 :CalendarH 或 :CalendarT 或 :CalendarVR
"Calendar e


" plugin config e


