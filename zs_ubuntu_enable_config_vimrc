" ubuntu 平台 vim7.3
"
" All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just
" /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime
" you can find below.  If you wish to change any of those settings, you should
" do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten
" everytime an upgrade of the vim packages is performed.  It is recommended to
" make changes after sourcing debian.vim since it alters the value of the
" 'compatible' option.

" This line should not be removed as it ensures that various options are
" properly set to work with the Vim-related packages available in Debian.
runtime! debian.vim

" Uncomment the next line to make Vim more Vi-compatible
" NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
" options, so any other options should be set AFTER setting 'compatible'.
"set compatible

" Vim5 and later versions support syntax highlighting. Uncommenting the next
" line enables syntax highlighting by default.
if has("syntax")
	syntax on
endif

" If using a dark background within the editing area and syntax highlighting
" turn on this option as well
"set background=dark

" Uncomment the following to have Vim jump to the last position when
" reopening a file
"if has("autocmd")
"  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
"endif

" Uncomment the following to have Vim load indentation rules and plugins
" according to the detected filetype.
"if has("autocmd")
"  filetype plugin indent on
"endif

" The following are commented out as they cause vim to behave a lot
" differently from regular Vi. They are highly recommended though.
"set showcmd		" Show (partial) command in status line.
"set showmatch		" Show matching brackets.
"set ignorecase		" Do case insensitive matching
"set smartcase		" Do smart case matching
"set incsearch		" Incremental search
"set autowrite		" Automatically save before commands like :next and :make
"set hidden             " Hide buffers when they are abandoned
"set mouse=a		" Enable mouse usage (all modes)

" Source a global configuration file if available
if filereadable("/etc/vim/vimrc.local")
	source /etc/vim/vimrc.local
endif


"zs config 注
"
"use: gg=:1,$ Enter 文件代码格式化

" 以下VIM配置,参考 pan.baidu.com 中的 zs_ubuntu压缩包中的;vim_ide文件夹

"常用变量
"$VIMRUNTIME
"$VIM : vim的安装的根目录.	[ad: ubuntu /usr/share/vim]
"
":echo $VIM
":ehco $VIMRUNTIME
":scriptname
"
":version


"zs config

"base config s
set tabstop=4			"设定tab宽度为4个字符
set softtabstop=4
set shiftwidth=4		"设定自动缩进为4个字符
"set noexpandtab        "不用space替代tab的输入
"set expandtab			"用space替代tab的输入
"%ret! 4				"每个tab用4个space替代
set autoindent
set number

"命令行提示有关设置 zs
set wildmenu
set showcmd

set nobackup
"set bg=dark		"显示不同的底色色调
set wrap        "自动折行


" 设置编码
" set enc=utf-8
" " 设置文件编码
" set fenc=utf-8
" " 设置文件编码检测类型及支持格式
" set fencs=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
" " 指定菜单语言
" set langmenu=zh_CN.UTF-8
" "解决consle输出乱码
" language messages zh_CN.utf-8
" "解决菜单乱码
" source $VIMRUNTIME/delmenu.vim
" source $VIMRUNTIME/menu.vim
set fileencoding=utf8  "默认文件编码
set fileencodings==utf8,gbk,cp936  "可以识别的文件编码;需要Linux系统支持中文方可

"打开文件都会显示^M符号
set fileformats=unix,dos
"转换文件换行方式
"解决方法：设置fileformat属性，:set ff=dos (\r\n win换行) :set ff=unix (\n unix/linux换行) :set ff=mac (\r Mac换行)
":set fileformats=unix,dos


"设置字体大小
"set guifont=Courier\\23		"在Linux种这样设置

" 中文帮助
" if version > 603
" set helplang=cn
" endif
"
"设置粘贴模式，这样粘贴过来的程序代码就不会错位了。zs注,很有用
"set paste


" 显示括号配对情况
set showmatch
" 自动缩进4空格
set cindent shiftwidth=4
" 智能自动缩进
set smartindent
" 设置自动缩进
set ai!


"显示光标的状态行
set guioptions-=T
""隐藏左、右侧滚动条
set guioptions-=r
set guioptions-=L


" 单行注释
" set comments=://
" " 段落注释
" set comments=s1:/*,mb:*,ex0:/

"与windows共享剪贴板
"set clipboard+=unnamed
"


"vim 中设置 tab 空格 等特殊字符 zs dev s
"
"配置:
"set list
"set listchars=tab:▸\ ,eol:-

" 显示 空格|TAB
" 命令行输入:
" :set list listchars=tab:>-,trail:-
"
"vim 中设置 tab 空格 等特殊字符 zs dev e

"
" 显示tab和空格   zs测试可用
" http://zshou.is-programmer.com/posts/39381
set list
" 设置tab和空格样式
set lcs=tab:\|\ ,nbsp:%,trail:-
" 设定行首tab为灰色
highlight LeaderTab guifg=#666666
" 匹配行首tab
match LeaderTab /^\t/

" 设定行尾tab为灰色 没效果
"highlight EndTab guifg=#666666
" 匹配行尾tab 没效果
"match EndTab /^\t/

"上面的设置将Tab显示为|(竖线)，将行尾的空格显示为-(减号)
"
":set list | :set nolist
"
" 显示tab和空格   zs测试可用

"
"vim打开时窗口设置默认大小
"lines是上下宽度,以行为单位
"columns是左右宽度,以字符个数为单位
"所以这句设置就是打开时为上下35行宽,左右118个字符宽的窗口
"set lines=35 columns=118


"设置状态栏标尺
set ruler               "可显示最后一行的状态
set showmode            "左下角那一行的状态
"高亮显示当前行
set cursorline
"hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
"高亮显示当前列
set cursorcolumn
"hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
" cursor
"set cursorline
"hi CursorLine ctermbg=lightgray cterm=NONE
"set cursorcolumn
"hi CursorColumn ctermbg=lightgray
"
"base config e
"


"ext config s

" history文件中需要记录的行数
set history=100
" 在处理未保存或只读文件的时候，弹出确认
set confirm


"set mouse=a		" Enable mouse usage (all modes)

" 语法高亮
syntax enable
"开启文件类型侦测
syntax on
" 针对不同的文件类型采用不同的缩进格式
filetype indent on
" 针对不同的文件类型加载对应的插件
filetype plugin on
" 启用插件
filetype plugin indent on

" set cmdheight=1	" 设定命令行的行数为 1
set laststatus=2	" 显示状态栏 (默认值为 1, 无法显示状态栏)
" set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\%c:%l/%L%)\		" 设置在状态行显示的信息


"search config s
"输入搜索内容时就显示搜索结果
set incsearch
set nohls
"搜索结果高亮显示
set hlsearch
"用nh去掉查找后的高亮 zs注 :noh是vim的命令;可以参考这个配置来配置其它vim命令的快捷键
nmap nh :noh<cr>
set ofu=syntaxcomplete#Complete
"搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感
set ignorecase smartcase
"search config e


" vim 代码折叠设置 s

"zs use
set fdm=indent
set autochdir				 " 自动切换当前目录为当前文件所在的目录


"set foldenable              " 开始折叠
"set foldmethod=syntax       " 设置语法折叠
"set foldcolumn=0            " 设置折叠区域的宽度
"setlocal foldlevel=1        " 设置折叠层数为
"set foldclose=all           " 设置为自动关闭折叠
"nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>		" 用空格键来开关折叠


" 打开javascript折叠
" javascript.vim 语法高亮
" ~/.vim/syntax/javascript.vim
let b:javascript_fold=1		"一般javascript编程，折叠层数不需要太深，我自己设置为1
" 打开javascript对dom、html和css的支持
let javascript_enable_domhtmlcss=1

" vim 代码折叠设置 e


"""""""
"VIM判断 操作系统 类型
"return OS type, eg: windows, or linux, mac, et.st..
"function! MySys()
"	if has("win16") || has("win32") || has("win64") || has("win95")
"		return "windows"
"	elseif has("unix")
"		return "linux"
"	endif
"endfunction

" 用户目录变量$VIMFILES
"if MySys() == "windows"
"   let $VIMFILES = $VIM.'/vimfiles'
"elseif MySys() == "linux"
"   let $VIMFILES = $HOME.'/.vim'
"endif

"设定doc文档目录
"let helptags=$VIMFILES.'/doc'


""""""""""""""""""""'
"F2处理行尾的空格以及文件尾部的多余空行
" zs 测试可用;暂时隐藏

" s
""Automatically remove trailing spaces when saving a file.
"autocmd BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif
""Remove indenting on empty line
"map <F2> :w<CR>:call CleanupBuffer(1)<CR>:noh<CR>
"function! CleanupBuffer(keep)
"	" Skip binary files
"	if (&bin > 0)
"		return
"	endif
"	" Remove spaces and tabs from end of every line, if possible
"	silent! %s/\s\+$//ge
"	" Save current line number
"	let lnum = line(".")
"	" number of last line
"	let lastline = line("$")
"	let n        = lastline
"	" while loop
"	while (1)
"		" content of last line
"		let line = getline(n)
"		" remove spaces and tab
"		if (!empty(line))
"			break
"		endif
"		let n = n - 1
"	endwhile
"	" Delete all empty lines at the end of file
"	let start = n+1+a:keep
"	if (start < lastline)
"		execute n+1+a:keep . "," . lastline . "d"
"	endif
"	" after clean spaces and tabs, jump back
"	exec "normal " . lnum . "G"
"endfunction
" e


" 高亮指定的列
" zs测试可用
" set cc=80
" set colorcolumn=80
map ch :set cc=150<CR>
"按下,ch就可以将当前光标下的列高亮
map nch :set cc=0<CR>
"按下,nch取消列高亮

"配合 vim Indent Guides 垂直对其插件
let g:indent_guides_guide_size=1
"zs注：vim7.3以后版本,不需要此插件。直接设置 ruler即可,见 line 201行设置


"zs 测试不可用
"map ch :call SetColorColumn()<CR>
"function! SetColorColumn()
"	let col_num = virtcol(".")
"	let cc_list = split(&cc, '')
"	if count(cc_list, string(col_num)) <= 0
"		execute "set cc+=".col_num
"	else
"		execute "set cc-=".col_num
"	endif
"endfunction
"按下,ch就可以将当前光标下的列高亮，再按下一次，取消高亮；并且可以同时多列高亮



"vim配置文件中的nnoremap和inoremap有什么区别:
"一个是在普通模式(normal mode)下生效的映射，一个是在插入模式(insert mode)下生效。
"这样可以在不同模式下使用同一个按键产生不同的效果。
"noremap 和 map 的区别是，被映射的序列不会再被递归映射))
"
"vim自动补全括号、引号 s
inoremap ( ()<ESC>i
inoremap ), (),<ESC>hi
inoremap ); ();<ESC>hi

inoremap [ []<ESC>i
inoremap ], [],<ESC>hi
inoremap ]; [];<ESC>hi

inoremap { {}<ESC>i
inoremap < <><ESC>i
inoremap " ""<ESC>i
inoremap ", "",<ESC>hi
inoremap "; "";<ESC>hi
inoremap ' ''<ESC>i
inoremap ', '',<ESC>hi
inoremap '; '';<ESC>hi
""可以写一个函数手动用call调用:
"function MyCompleteAdd()
"	inoremap ( ()<ESC>i
"	inoremap [ []<ESC>i
"	inoremap { {}<ESC>i
"	inoremap < <><ESC>i
"	inoremap " ""<ESC>i
"	inoremap ' ''<ESC>i
"endfunction
"function MyCompleteDel()
"	noremap ( (
"	inoremap [ [
"	inoremap { {
"	inoremap < <
"	inoremap " "
"	inoremap ' '
"endfunction
"vim自动补全括号、引号 e

""""""""""""""""""""'


"zs 注 vim 绑定快捷键 s
"
"zs use s
"Alt快捷键定义方式 : Alt+o
"map <A-o> <ESC>:bp<CR>
"Ctrl快捷键定义方式 : Ctrl+o
"map <C-o> <ESC>:bp<CR>
"Shift快捷键定义方式 : Shift+o
"map <S-o> <ESC>:bp<CR>
"zs use e
"
"适用于普通模式的映射命令有：
"1. :map 
"[语法] :map {lhs} {rhs} |mapmode-nvo| *:map* 
"1.1 作用模式： n、v、o （普通、可视和选择、操作符等待） 
"1.2 命令格式： 
":map {lhs} {rhs} 
"含义： 在:map作用的模式中把键系列 {lhs} 映射为
"{rhs}，{rhs}可进行映射扫描，也就是可递归映射。 
"1.3 举例： 
":map td :tabnew .<cr> 
"含义：在其作用模式（普通、可视、操作符）下，输入td等价于输入 :tabnew .
"<cr>。而普通模式下输入:tabnew . <cr>就是打开当前目录 
"如果再定义绑定 :map ts
"td，就是指在其作用模式下输入ts等价于td，也就是打开当前目录。不过如果没有特殊需要，一般不建议递归映射。 
"
"zs 注 vim 绑定快捷键 e
"

" zs 配置快捷键
" 垂直增加10宽度
map vr+ :vertical resize +10<CR>
" 垂直减少10宽度
map vr- :vertical resize -10<CR>
" 水平增加10宽度
map r+  :resize +10<CR>
" 水平减少10宽度
map r-  :resize -10<CR>
"
"开启行号
map nu :set nu<CR>
"关闭行号
map nnu :set nonu<CR>

" 保存当前窗口
map s :w<CR>
" 保存当前窗口
map sq :wq<CR>
" 保存当前窗口
map sa :wqa<CR>

" 不保存退出当前窗口
map qq :q!<CR>
" 不保存打开的所有窗口
map qa :qa!<CR>
" Ctrl + v = Esc

" 退到 linux终端
map shl :sh<CR>

"zs ext注:
"
":set ic设置搜索时忽略大小写 
":set noic搜索时对大小写敏感 
":set list显示不可视字符 
":set nolist不显示不可视字符 
":set showmode显示当前操作模式 
":set shownomode不显示当前操作模式 
":set显示所有的vi环境变量设置 
":set all显示所有的vi环境变量可能取值及其当前设置值 
"你也可以把这些操作放在home目录下你创建的文件.exec中，set操作放在该文件中，不用带前面的：，一行一个命令，一旦该文件存在时，每次你开启一个vi会话时系统将取读取该文件来设置对应的vi环境变量
"

"ext config e



" plugin config s

"color theme s		|zzz
"
"ubuntu 需要使用 solarized.sh脚本, dir:~/zs_ubuntu/vim_ide/solarized.sh
"
"一般的Linux发行版默认的终端都是16色的，但事实上几乎所有的终端都支持256色终端
"1.将Terminal设为Xterm模式:编辑->配置文件首选项->颜色
"设置为自定义,内置方案选择XTerm.
"2.vimrc里设置：set t_Co=256
"
"syntax enable
if has('gui_running')
	set background=light
else
	set background=dark
endif
set t_Co=16		"需要添加,否则会出现 文字 有阴影的情况
colorscheme solarized
"set background=dark
"
"colorscheme desert
"color theme e

""""""

"javascript		|zz
"javascript ide s
"
"javascript dict
autocmd FileType javascript set dictionary=~/.vim/dict/javascript.dict
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
":set omnifunc=javascriptcomplete#CompleteJS
"
"javascript ide e



"php ide s


"colorscheme peachpuff

"php缩进
let PHP_autoformatcomment=1
"
" Enable enhanced command line completion.
set wildmenu wildmode=list:full
" Ignore these filenames during enhanced command line completion.
set wildignore+=*.aux,*.out,*.toc " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif " binary images
set wildignore+=*.luac " Lua byte code
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.pyc " Python byte code
set wildignore+=*.spl " compiled spelling word lists
set wildignore+=*.sw? " Vim swap files
"
"
" You might also find this useful
" PHP Generated Code Highlights (HTML & SQL)
" let php_sql_query=1
" let php_htmlInStrings=1
" let g:php_folding=2
" set foldmethod=syntax
"
"
" syntax enable
" source ~/.vim/syntax/php.vim
"

"php complete|Autocomplete|vim php autocomplete s
"
"一、如何安装phpcomplete插件
"如果是VIM7.0以上，不需要再下载 phpcomplete.vim 这个插件，因为安装时自带了，在目录/usr/share/vim/vim73/autoload/phpcomplete.vim中。
""在 ~/.vimrc 中添加这样两行：
"filetype plugin on
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
set ofu=syntaxcomplete#Complete
"#只有在是PHP文件时，才启用PHP补全
"
"php complete e


"php 中 一般是会在 "$", "->", "::" 后需要出现自动补全，在 .vimrc 中加入以下代码：
if !exists('g:AutoComplPop_Behavior')
	let g:AutoComplPop_Behavior = {}
	let g:AutoComplPop_Behavior['php'] = []
	call add(g:AutoComplPop_Behavior['php'], {
				\   'command'   : "\<C-x>\<C-o>",
				\   'pattern'   : printf('\(->\|::\|\$\)\k\{%d,}$', 0),
				\   'repeat'    : 0,
				\})
endif


"php 函数字典	|zzz
"php 函数字典 s

"autocmd FileType php set dictionary+=~/.vim/php_funclist.dict
"autocmd FileType php set complete+=~/.vim/php_funclist.dict

"""""""""

"set dictionary-=/usr/share/vim/dict/php.dict dictionary+=/usr/share/vim/dict/php.dict
" 设置自动完成的监听方式：尾部添加一个字母和清除一个字母
"set complete-=k complete+=k

" 智能Tab补全的代码，它会根据上下文自动选择补全模式：
"inoremap <tab> <c-r>=Smart_TabComplete()<CR>
"function! Smart_TabComplete()
"  let line = getline('.')                         " current line
"
"  let substr = strpart(line, -1, col('.')+1)      " from the start of the current
"                                                  " line to one character right
"                                                  " of the cursor
"  let substr = matchstr(substr, "[^ \t]*$")       " word till cursor
"  if (strlen(substr)==0)                          " nothing to match on empty string
"    return "\<tab>"
"  endif
"  let has_period = match(substr, '\.') != -1      " position of period, if any
"  let has_slash = match(substr, '\/') != -1       " position of slash, if any
"  if (!has_period && !has_slash)
"    return "\<C-X>\<C-P>"                         " existing text matching
"  elseif ( has_slash )
"    return "\<C-X>\<C-F>"                         " file matching
"  else
"    return "\<C-X>\<C-O>"                         " plugin matching
"  endif
"endfunction

""""""""""

"设置字典自动完成
set complete+=k
"设置字典
set dictionary=~/.vim/php_funclist.dict
"" 自动完成使用TAB键
"This function determines, wether we are on
""the start of the line text(then tab indents)
"or if we want to try auto completion
function! InsertTabWrapper()
	let col=col('.')-1
	if !col || getline('.')[col-1] !~ '\k'
		return "\<TAB>"
	else
		return "\<C-N>"
	endif
endfunction
"使用SuperTab之后，就可以关闭该设置了
inoremap <TAB> <C-R>=InsertTabWrapper()<CR>

"php 函数字典 e


"quickfix s
"vim7.3 已经集成此插件,无需另外安装
"set makeprg=php\ -ln\ %
"set errorformat=%m\ in\ %f\ on\ line\ %l
"nmap <f9> :sil! make<cr>:cwindow<cr>

" php quickfix
" zs 测试可用
" 639
setlocal makeprg=php\ -ln\ %
setlocal errorformat=%m\ in\ %f\ on\ line\ %l
"nmap <buffer> <f9> :sil! make<cr>:cwindow<cr>
nmap <buffer> <C-p> :sil! make<cr>:cwindow<cr>

" javascript |nodejs quickfix
" zs 测试可用
""sudo apt-get install npm
""sudo npm -g install jslint
"set makeprg=jslint\ %
"set errorformat=%-P%f,
"        \%E%>\ #%n\ %m,%Z%.%#Line\ %l\\,\ Pos\ %c,
"        \%-G%f\ is\ OK.,%-Q
"":make
"nmap <buffer> <C-j> :sil! make<cr>:cwindow<cr>
"quickfix e


"phpdocumentor插件 s
"
"http://www.vim.org/scripts/script.php?script_id=1355
"下载php-doc.vim
"cp ./php-doc.vim /usr/share/vim/vim73/autoload/php-doc.vim
"
"如何使用：
"在函数定义出注释按ctrl+p即可
"
"source ~/.vim/php-doc.vim
"inoremap <C-P> <ESC>:call PhpDocSingle()<CR>i
"nnoremap <C-P> :call PhpDocSingle()<CR> 
"vnoremap <C-P> :call PhpDocRange()<CR>
"
"phpdocumentor插件 e
"
" run file with PHP CLI (CTRL-M)
" :autocmd FileType php noremap <C-M> :w!<CR>:!/usr/bin/php %<CR>
"
" PHP parser check (CTRL-L)
" :autocmd FileType php noremap <C-L> :!/usr/bin/php -l %<CR>
"
" Do use the currently active spell checking for completion though!
" (I love this feature :-)
" set complete+=kspell


" assistant.vim		|zzz
" assistant.vim s
" php语法增强插件
"
"assistant.vim文件 配置 assistant支持的语言
"let s:aType = {}
"let s:aType = { 
"|             \'php':'php', 'phps':'php', 'phtml':'php',
"|   |   |     \'vim':'vim', 'vimrc':'vim'
"|   |   |     \}  
 
"打开 assistant.vim文件 查看如何使用 assistant插件
"Description:  1. Display the definition of functions, variables, etc(<C-k>).
"|   |   |     2. Complete keywords(<C-x><C-u>).
"Description:提示 使用 Ctrl + k , Ctrl + x , Ctrl + u快捷键
"
"assistant.vim e


"Autocompletition s

"Autocompletition e


"php 语法检查	|z
"zs 测试中
" 见559行 quickfix
"
"function! CheckSyntax()
"	if &filetype!="php"
"		echohl WarningMsg | echo "Fail to check syntax! Please select the right file!" | echohl None
"		return
"	endif
"	if &filetype=="php"
"		setlocal makeprg=\"php\"\ -l\ -n\ -d\ html_errors=off
"		setlocal shellpipe=>
"		setlocal errorformat=%m\ in\ %f\ on\ line\ %l
"	endif
"	execute "silent make %"
"	set makeprg=make
"	execute "normal :"
"	execute "copen"
"endfunction
""map <F7> :call CheckSyntax()<CR>
"map cs :call CheckSyntax()<CR>


" php ide ext s

"php code_sniffer,php-md. phpqa.vim s	|z
"zs 测试中
"
"php code_sniffer 默认安装目录:/usr/bin/phpcs
"php mess Detector 默认安装目录:/usr/bin/phpmd

"let g:phpqa_codesniffer_args = "--standard=Zend"
"let g:phpqa_codesniffer_cmd  = '/usr/bin/phpcs'
"let g:phpqa_codesniffer_autorun = 1        "default =1 on save
"let g:phpqa_messdetector_ruleset = ''
"let g:phpqa_messdetector_cmd = '/usr/bin/phpmd'
"let g:phpqa_messdetector_autorun = 0

"zs use
"在 linux终端执行
":!php -l % 这个是检查当前php文件语法参数
"
"phpcs -h
":phpcs 这个就是code sniffer了
"
":phpmd  这个是mess detector , 需要一个XML规则文件如果没有设置
"
":phpcc  这个显示code coverage. 也需要一个XML规则文件如果没有设置
"

"ext:
"
"php code_sniffer
"参数里面的 --standard=Zend 意思是codesniffer采用Zend的编码风格来效验。
"你可以自定义一些效验规则， 这个规则在debian里面
"/usr/share/php/PHP/CodeSniffer/Standards/ 
"里面，你可以把自定义的放进去。然后把
"let g:phpqa_codesniffer_args = "--standard=Zend"
"改为
"let g:phpqa_codesniffer_args = "--standard=自定义的"
"就可以使用自定义的代码风格效验了.

"php code_sniffer,php-md. phpqa.vim e


"phpcpd s
"PHP Copy Paste Detector(https://github.com/sebastianbergmann/phpcpd)
"顾名思义，检查冗余代码的

"phpcpd e

"phpdcd s
"PHP Dead Code Detector(https://github.com/sebastianbergmann/phpdcd)
"看名字就知道了，检查从未被调用过的方法

"phpdcd s



"xdebug | Vdebug	|z
"vim DBGp client s
"
"设置dbgp客户端要监听的端口号		|注意：要与xdebug.ini中端口配置一致
"let g:debuggerPort = 9000
let g:debuggerPort = 9001
"为了能看到php数组的值，还需要设置下.vimrc
let g:debuggerMaxDepth = 5

"zs use
":Bp		"设置断点

"dbgp 快捷键
"vim DBGP快捷键和 ubuntu系统快捷键冲突,解决:
"自定义配置 示例来自  debugger.vim文件
"map <F1> :python debugger_resize()<cr>
"map <F2> :python debugger_command('step_into')<cr>
"map <F3> :python debugger_command('step_over')<cr>
"map <F4> :python debugger_command('step_out')<cr>
"
"map <Leader>dr :python debugger_resize()<cr>
"map <Leader>di :python debugger_command('step_into')<cr>
"map <Leader>do :python debugger_command('step_over')<cr>
"map <Leader>dt :python debugger_command('step_out')<cr>
"
"nnoremap ,e :python debugger_watch_input("eval")<cr>A
"
"map <F5> :python debugger_run()<cr>
"map <F6> :python debugger_quit()<cr>
"
"map <F7> :python debugger_command('step_into')<cr>
"map <F8> :python debugger_command('step_over')<cr>
"map <F9> :python debugger_command('step_out')<cr>
"
"map <F11> :python debugger_context()<cr>
"map <F12> :python debugger_property()<cr>
"map <F11> :python debugger_watch_input("context_get")<cr>A<cr>
"map <F12> :python debugger_watch_input("property_get", '<cword>')<cr>A<cr>
"
"hi DbgCurrent term=reverse ctermfg=White ctermbg=Red gui=reverse
"hi DbgBreakPt term=reverse ctermfg=White ctermbg=Green gui=reverse
"
"command! -nargs=? Bp python debugger_mark('<args>')
"command! -nargs=0 Up python debugger_up()
"command! -nargs=0 Dn python debugger_down()
"sign define current text=->  texthl=DbgCurrent linehl=DbgCurrent
"sign define breakpt text=B>  texthl=DbgBreakPt linehl=DbgBreakPt
"....

"RADME DBGP
"因为窗口不大，那4个小窗口只有watch_window对我有用，所以可以直接修改debugger.py，把对应窗口的代码都注视掉，只留下watch_window，这样watch_window就独占右侧了
"
"minibufexplorer 插件,在执行 DBGP调试的时候,会使窗口混乱;尚未找到解决方法
"vim 设置折叠,在进行 DBGP调试的时候,也不是很友好,可以设置 vim打开文件默认不开启折叠

"vim DBGP config s
"There are some variables that you can configure in Vim:
"
"g:debuggerPort [9000]
"The port that the plugin will use to receive the connections from the
"debugger
"g:debuggerProxyHost [localhost]
"Host where the proxy is
"g:debuggerProxyPort
"Port used to connect to the proxy, leave it unset if not using proxy
"g:debuggerProxyKey
"Key used in the connection with the proxy
"g:debuggerMaxChildren [32]
"TODO
"g:debuggerMaxData [32]
"TODO
"g:debuggerMaxChildren [1024]
"TODO
"g:debuggerMaxDepth [1]
"Maximum depth level when dumping variables
"g:debuggerMiniBufExpl [0]
"TODO
"g:debuggerFileMapping [[]]
"Array with pairs of regular expressions to match and replacement strings,
"e,g: [['/var/www/[^/]+/(.*)', '/home/' . $USER . '/project/\\1']]
"vim DBGP config e

"vim DBGp client e


"vim php debug README s
"vim DBGP|[xdebug]
"vim php调试

"PHP Mess Detector(http://phpmd.org/)
"PHP项目体检工具，根据你设定的标准（如单一文件代码体积，未使用的参数个数，未使用的方法数）检查PHP代码，超出设定的标准时报警。

"PHP Copy Paste Detector(https://github.com/sebastianbergmann/phpcpd)
"顾名思义，检查冗余代码的

"PHP Dead Code Detector(https://github.com/sebastianbergmann/phpdcd)
"看名字就知道了，检查从未被调用过的方法

"PHP Code Sniffer(http://pear.php.net/package/PHP_CodeSniffer)
"老牌代码格式化工具，PHP写的，Pear包，可自己hack，可集成到命令行里。

"Code Beautifier，只有Windows GUI，Windows CMD很难用，已经打算跳槽到PHP CS了
"你还可以用jenkins把上述工具以plugins形式整合起来，做持续集成：http://jenkins-php.org/
"你还可以用xinc+phing跟上述工具集成起来做持续集成后的自动化打包发布：http://code.google.com/p/xinc/

"PHPLint http://www.icosaedro.it/phplint/
"vim php debug README e

" php ide ext e


"php ide e


"html自动补全	|zz
"html自动补全 s
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
"html自动补全 e


"html_autoclosetag.vim	|z
"html_autoclosetag.vim s
"html自动输入匹配标签，输入>之后自动完成匹配标签
"au FileType xhtml,xml so ~/.vim/ftplugin/html_autoclosetag.vim
"html_autoclosetag.vim e


"MiniBufExplorer	|zzzz
"多文件编辑 s
""MiniBufExplorer
let g:miniBufExplMapWindowsNavVim=1		"可以用<C-h,j,k,l>切换到上下左右的窗口中去
let g:miniBufExplMapWindowNavArrows=1		"用<C-箭头键>切换到上下左右窗口中去
let g:miniBufExplMapCTabSwitchWindows=1

"<C-Tab> 向前循环切换到每个buffer上,并在但前窗口打开
"<C-S-Tab> 向后循环切换到每个buffer上,并在但前窗口打开
let g:miniBufExplMapCTabSwitchBufs=1

"let g:miniBufExplModSelTarget = 1

"解决FileExplorer窗口变小问题
"let g:bufExplorerMaxHeight=40
"let g:miniBufExplorerMoreThanOne=0		"这个设置保证在打开0个以上的文件是最高限制都是有用的

" MiniBufExpl Colors
"hi MBENormal               guifg=#808080 guibg=fg
"hi MBEChanged              guifg=#CD5907 guibg=fg
"hi MBEVisibleNormal        guifg=#5DC2D6 guibg=fg
"hi MBEVisibleChanged       guifg=#F1266F guibg=fg
"hi MBEVisibleActiveNormal  guifg=#A6DB29 guibg=fg
"hi MBEVisibleActiveChanged guifg=#F1266F guibg=fg

"minibufexplorer其它常用命令
" :MiniBufExplorer  ,mbe   " Open and/or goto Explorer
" :CMiniBufExplorer ,mbc  " Close the Explorer if it's open
" :UMiniBufExplorer ,mbu  " Update Explorer without naviting
" :TMiniBufExplorer ,mbt  " Toggle the Explorer window open and closed
"多文件编辑 e
"Alt + -> 打开下一个文件,zs set
"map <M-right> <ESC>:bn<RETURN>
map <A-right> <ESC>:bn<RETURN>
"Alt + <- 打开上一个文件,zs set
"map <M-left> <ESC>:bp<RETURN>
map <A-left> <ESC>:bp<RETURN>


"NERDTree	|zzz
"NERDTree s
"目录插件
"map <F1> :NERDTreeToggle<CR>
"map <C-F1> :NERDTreeFind<CR>
"let NERDTreeChDirMode=2  "选中root即设置为当前目录
"let NERDTreeQuitOnOpen=1 "打开文件时关闭树
"let NERDTreeShowBookmarks=1 "显示书签
"let NERDTreeMinimalUI=1 "不显示帮助面板
"let NERDTreeDirArrows=1 "目录箭头 1显示箭头  0传统+-|号
"map <F3> :NERDTreeToggle<CR>		"F3快捷键,zs set
"nmap ne :NERDTreeToggle<CR>		"ne快捷键
"NERDTree e



"Trinity	|zzzz
"Trinity s

"集成, NERD_tree,taglist,srcexpl 三个插件
" Open and close all the three plugins on the same time 
"nmap tta  :TrinityToggleAll<CR> 
nmap tta  :TrinityToggleAll<CR> 
" Open and close the Source Explorer separately 
"nmap tts  :TrinityToggleSourceExplorer<CR> 
nmap tts  :TrinityToggleSourceExplorer<CR> 
" Open and close the Taglist separately 
"nmap ttl :TrinityToggleTagList<CR> 
nmap ttl :TrinityToggleTagList<CR> 
" Open and close the NERD Tree separately 
"nmap ttn :TrinityToggleNERDTree<CR> 
nmap ttn :TrinityToggleNERDTree<CR> 

"----

"NERD_Tree s
"NERD_Tree config
"NERD_Tree e

"taglist s
"taglist config
"taglist e

"srcexpl s
"SrcExpl 类比与 Taglist + Ctags 跳转插件
"
"回车跳转到定义的文本，空格跳转回来
"
"zs use
"sudo apt-get install ctags
"cd ./project
"sudo ctags -R *
"先跳到 SrcExpl窗口指定的行 -> 按下<ENTER>跳转到函数处, 按下 <SPACE>跳转回原处
"
"srcexpl config
"
""=================== SrcExpl ==================== 
"zs 测试中:
"nmap <F5> :SrcExplToggle<CR> "快捷键映射 let g:SrcExpl_winHeight = 8 "默认高度 let g:SrcExpl_refreshTime = 100 "更新时间(ms) let g:SrcExpl_isUpdateTags = 0 "每次打开SrcExpl时是否更新tags(0为不更新) let g:SrcExpl_updateTagsKey = "<F12>" "更新tags的快捷键
"
"" // The switch of the Source Explorer 
"nmap <F8> :SrcExplToggle<CR> 
"
"" // Set the height of Source Explorer window 
"let g:SrcExpl_winHeight = 8 
"
"" // Set 100 ms for refreshing the Source Explorer 
"let g:SrcExpl_refreshTime = 100 
"
"" // Set "Enter" key to jump into the exact definition context 
"let g:SrcExpl_jumpKey = "<ENTER>" 
"
"" // Set "Space" key for back from the definition context 
"let g:SrcExpl_gobackKey = "<SPACE>" 
"
"" // In order to avoid conflicts, the Source Explorer should know what plugins
"" // except itself are using buffers. And you need add their buffer names into
"" // below listaccording to the command ":buffers!"
"let g:SrcExpl_pluginList = [ 
"        \ "__Tag_List__", 
"        \ "_NERD_tree_" 
"    \ ] 
"
"" // Enable/Disable the local definition searching, and note that this is not 
"" // guaranteed to work, the Source Explorer doesn't check the syntax for now. 
"" // It only searches for a match with the keyword according to command 'gd' 
"let g:SrcExpl_searchLocalDef = 1 
"
"" // Do not let the Source Explorer update the tags file when opening 
"let g:SrcExpl_isUpdateTags = 0 
"
"" // Use 'Exuberant Ctags' with '--sort=foldcase -R .' or '-L cscope.files' to 
"" // create/update the tags file 
"let g:SrcExpl_updateTagsCmd = "ctags --sort=foldcase -R ." 
"
"" // Set "<F12>" key for updating the tags file artificially 
"let g:SrcExpl_updateTagsKey = "<F12>" 
"let g:SrcExpl_updateTagsKey = "<C-s>" 
"
"" // Set "<F3>" key for displaying the previous definition in the jump list 
"let g:SrcExpl_prevDefKey = "<F3>" 
"
"" // Set "<F4>" key for displaying the next definition in the jump list 
"let g:SrcExpl_nextDefKey = "<F4>" 
"srcexpl e

"Trinity e



"neocomplcache		|zzzz
"neocomplcache s
"自动补全插件
let g:neocomplcache_enable_at_startup = 1
"neocomplcache e


"autocomplpop s
"自动补全插件

"autocomplpop e


"DoxygenToolkit		|zz
"DoxygenToolkit s
"生成注释

"doxygen toolkit
let g:DoxygenToolkit_briefTag_pre="Function name "
"let g:DoxygenToolkit_briefTag_post = "<++>"
let g:DoxygenToolkit_paramTag_pre="@Param Param "
let g:DoxygenToolkit_returnTag="@Returns Returns"
"let g:DoxygenToolkit_blockHeader="--------------------------------------------------------------------------"
"let g:DoxygenToolkit_blockFooter="--------------------------------------------------------------------------"
let g:DoxygenToolkit_authorName="weiyan"
let g:DoxygenToolkit_licenseTag="license v"
let g:DoxygenToolkit_authorName="weiyan, weiyan@b5m.com"
let s:licenseTag = "Copyright(C)\<enter>"
let s:licenseTag = s:licenseTag . "For free\<enter>"
let s:licenseTag = s:licenseTag . "All right reserved\<enter>"
let g:DoxygenToolkit_licenseTag = s:licenseTag
let g:DoxygenToolkit_briefTag_funcName = "yes"
"let g:DoxygenToolkit_commentType= "php"
let g:DoxygenToolkit_compactDoc = "yes"
"let g:DoxygenToolkit_throwTag_pre = "yes"
let g:DoxygenToolkit_cinoptions = "no"
let g:doxygen_enhanced_color=1

"F1为添加文件头快捷键
"au FileType cpp map <F1> :DoxAuthor<CR>
"au FileType python map <F1> :DoxAuthor<CR>
"F2为添加函数注释
"au FileType cpp map <F2> :Dox<CR>
"au FileType python map <F2> :Dox<CR>

"" use doxygen 这个工具
"光标在函数上，用 :Dox 自动生成函数的说明
"光标在文件头，用 :DoxAuthor 自动生成文件说明
"用 :DoxLic
"可以结合doxygen自动生成各种格式的文档

"DoxygenToolkit e


" 状态栏颜色配置 s		|zzzz

if version >= 700
	au InsertEnter * hi StatusLine term=reverse ctermbg=5 gui=undercurl guisp=Magenta
	au InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=2 gui=bold,reverse
endif
"插入模式也有很多种派生的状态 s
function! InsertStatuslineColor(mode)
	if a:mode == 'i'
		hi statusline guibg=magenta
	elseif a:mode == 'r'
		hi statusline guibg=blue
	else
		hi statusline guibg=red
	endif
endfunction
au InsertEnter * call InsertStatuslineColor(v:insertmode)
au InsertChange * call InsertStatuslineColor(v:insertmode)
au InsertLeave * hi statusline guibg=green
" default the statusline to green when entering Vim
hi statusline guibg=green
"插入模式也有很多种派生的状态 e

" 状态栏颜色配置 e


"CTags	|zzzz
"CTags s
""let Tlist_Ctags_Cmd="/usr/share/CTags"		"linux 下 ctags执行文件目录
"let Tlist_Ctags_Cmd="/usr/bin/ctags"		"linux 下 ctags执行文件目录

"Taglist	|zzzz
"Taglist s
""map <silent> <leader>tl :TlistToogle<cr>
"let Tlist_Auto_Highlight_Tag = 1
"let Tlist_Auto_Open = 1
"let Tlist_Auto_Update = 1
"let Tlist_Close_On_Select = 0
"let Tlist_Compact_Format = 0
"let Tlist_Display_Prototype = 0
"let Tlist_Display_Tag_Scope = 1
"let Tlist_Enable_Fold_Column = 0
"let Tlist_Exit_OnlyWindow = 0
"let Tlist_File_Fold_Auto_Close = 0
"let Tlist_GainFocus_On_ToggleOpen = 1
"let Tlist_Hightlight_Tag_On_BufEnter = 1
"let Tlist_Inc_Winwidth = 0
"let Tlist_Use_Right_Window = 1
""map <silent> <leader>tl :TlistToogle<cr>
""map <F4> :TlistToggle<CR>		"F4快捷键,zs set
""map tl :TlistToggle<CR>		"tl快捷键,
"
"let Tlist_Show_One_File = 1            "不同时显示多个文件的tag，只显示当前文件的
"let Tlist_Exit_OnlyWindow = 1          "如果taglist窗口是最后一个窗口，则退出vim
"let Tlist_Use_Right_Window = 1         "在右侧窗口中显示taglist窗口
""map <silent> <F9> :TlistToggle<cr>
"Taglist e

"Ctags 生成的tags文件路径
"set tags=/var/www/html/zixun/tags
" 增强检索功能
"set tags=./tags,./../tags,./**/tags

"""""""""""""""""""""""
""F12生成/更新tags文件
"set tags=tags;
"set autochdir
"function! UpdateTagsFile()
"	silent !ctags -R --fields=+ianS --extra=+q
"endfunction
"nmap <F12> :call UpdateTagsFile()<CR>
"
""Ctrl + F12删除tags文件
"function! DeleteTagsFile()
"	"Linux下的删除方法
"	"silent !rm tags
"	"Windows下的删除方法
"	silent !del /F /Q tags
"endfunction
"nmap <C-F12> :call DeleteTagsFile()<CR>
""退出VIM之前删除tags文件
""au VimLeavePre * call DeleteTagsFile()
"""""""""""""""""""""""
"
"zs use: Ctrl+] || Ctrl+t
"
"CTags e


"vim tab补全插件 s
"SuperTab.vim
"下载 supertab.vim
"sudo cp supertab.vmb /usr/share/vim/vim73/plugin/supertab.vim
"
"config s
"let g:SuperTabRetainCompletionType=2
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"

"以后当你准备按"Ctrl+X Ctrl+O"的时候直接按<Tab>就好了, 够爽吧 ....

"我稍微再介绍一下上面那两句配置信息:
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"
" 设置按下<Tab>后默认的补全方式, 默认是<C-P>,
" " 现在改为<C-X><C-O>. 关于<C-P>的补全方式,
" " 还有其他的补全方式, 你可以看看下面的一些帮助:
" " :help ins-completion
" " :help compl-omni
"
" let g:SuperTabRetainCompletionType=2
" " 0 - 不记录上次的补全方式
" " 1 - 记住上次的补全方式,直到用其他的补全命令改变它
" " 2 - 记住上次的补全方式,直到按ESC退出插入模式为止
"config s
"
"
"""""""""""""""""""""""""""
"vim 中SuperTab的安装和使用
"『插件介绍』
"SuperTab使Tab快捷键具有更快捷的上下文提示功能。
"
"『下载和安装』
"从http://www.vim.org/scripts/script.php?script_id=1643下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。
"    1）用Vim打开.vba安装包文件。
"    2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。
"    3）在~/.vimrc文件中加入以下这行：
"       let g:SuperTabDefaultCompletionType="context"
"
"      『基本功能使用方法』
"      SuperTab使用很简单，只要在输入变量名或路径名等符号中途按Tab键，就能得到以前输入过的符号列表，并通过Tab键循环选择。
"""""""""""""""""""""""""""
"
"vim tab补全插件 e



"snipMate	|zzzz
"snipMate s
"片断补全,可自定义补全片段
"
"重启vim。
"如果还是不可以的话。可以在gvim任意打开一个文件，然后输入以下命令查看vim文件夹路径，并修改第3步中路径参数。
":echo $VIM                <<=================>>          D:/安装目录/Vim
":echo $VIMRUNTIME         <<=================>>	   	D:/安装目录/Vim/vim72
"(按tab快速生成代码段)
"
"let g:snippets_dir='$VIMRUNTIME/snippets'
"let g:snippets_dir='~/.vim/snipMate'
"
"
"////////////////////////////////
"打开vim分别输入以下几行命令
":echo $VIM
":ehco $VIMRUNTIME
":scriptname
"
"前两个会输出vim的路径,我这里的路径为
"/usr/shre/vim/
"/usr/shre/vim/vim73
"第三个会输出vim加载的脚本名,可以看到这里是没有加载/snipMate 的
"filetype plugin on
"
"
"zs 注:
"在 .vimrc里面添加配置
"set runtimepath=/usr/share/vim/vim73,~/vim,~/vim/after
"let g:snippets_dir='~/.vim/snippets'
"注：上述路径是自己的安装目录，根据自己情况进行修改。
"ubuntu直接放在 ~./vim/目录下即可; 很多其它插件可类比
"
"...zs需要研究,vim snipMate的自定义配置方法
"
"snipMate e
"


"Tabular	|zzzz
"vim 赋值[但不限于]符号对齐 s
"Tabular
"有时候我们可能希望我们一段的赋值代码都用=号对齐

"添加 Tabularize映射
let mapleader=','
if exists(":Tabularize")
	nmap <Leader>a= :Tabularize /=<CR>
	vmap <Leader>a= :Tabularize /=<CR>
	nmap <Leader>a: :Tabularize /:\zs<CR>
	vmap <Leader>a: :Tabularize /:\zs<CR>
endif

inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a

function! s:align()
	let p = '^\s*|\s.*\s|\s*$'
	if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
		let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
		let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
		Tabularize/|/l1
		normal! 0
		call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
	endif
endfunction

"zs use
"V 选择要对齐的行
"按 : 进入命令模式; 此时命令行会显示 :'<,'>
"输出对齐命令: Tabularize /=
"此时 命令行 如下
":'<,'>Tabularize /=
"直接回车即可 按照 = 对齐
"
"map <F6> :Tabularize /=<CR>		"F6快捷键,zs set
map t= :Tabularize /=<CR>		"t=快捷键,zs set


"解决方法：安装Tabular插件，选中要对齐的代码，输入:Tab/= 让代码通过=两边对齐

"V 选择, 之後在下面繼續打, 都會自動排序. (若文字過長, 上面都會自動對齊)
"
":Tab/ 後面接要分隔的符號, ex: 上述是用 "|" 分隔, 所以輸入 :Tab/|, 程式若要排
""=", 則輸入 :Tab/=, 更多範例可見下述:

":Tab/:
":Tab/=
":Tab/:\zs # 只有排序 ":" 後面的文字

"vim 赋值[但不限于]符号对齐 e


"日历
"Calendar s		|zz
let g:calendar_diary = "~/diary" " 设置日记的存储路径
let g:calendar_monday = 1 "以星期一为开始
let g:calendar_focus_today = 1 " 光标在当天的日期上
let g:calendar_mark = 'left-fit' "可以让*和数字可靠近
"在vimrc中设置let g:calendar_diary = "~/diary"
"这是设置日记的存放目录，必须自己先建立这个目录。
""打开vim，用:Calendar 或 :CalendarH 或 :CalendarT 或 :CalendarVR
"Calendar e


" plugin config e


