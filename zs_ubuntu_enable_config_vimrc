" All system-wide defaults are set in $VIMRUNTIME/debian.vim (usually just
" /usr/share/vim/vimcurrent/debian.vim) and sourced by the call to :runtime
" you can find below.  If you wish to change any of those settings, you should
" do it in this file (/etc/vim/vimrc), since debian.vim will be overwritten
" everytime an upgrade of the vim packages is performed.  It is recommended to
" make changes after sourcing debian.vim since it alters the value of the
" 'compatible' option.

" This line should not be removed as it ensures that various options are
" properly set to work with the Vim-related packages available in Debian.
runtime! debian.vim

" Uncomment the next line to make Vim more Vi-compatible
" NOTE: debian.vim sets 'nocompatible'.  Setting 'compatible' changes numerous
" options, so any other options should be set AFTER setting 'compatible'.
"set compatible

" Vim5 and later versions support syntax highlighting. Uncommenting the next
" line enables syntax highlighting by default.
if has("syntax")
	syntax on
endif

" If using a dark background within the editing area and syntax highlighting
" turn on this option as well
"set background=dark

" Uncomment the following to have Vim jump to the last position when
" reopening a file
"if has("autocmd")
"  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
"endif

" Uncomment the following to have Vim load indentation rules and plugins
" according to the detected filetype.
"if has("autocmd")
"  filetype plugin indent on
"endif

" The following are commented out as they cause vim to behave a lot
" differently from regular Vi. They are highly recommended though.
"set showcmd		" Show (partial) command in status line.
"set showmatch		" Show matching brackets.
"set ignorecase		" Do case insensitive matching
"set smartcase		" Do smart case matching
"set incsearch		" Incremental search
"set autowrite		" Automatically save before commands like :next and :make
"set hidden             " Hide buffers when they are abandoned
"set mouse=a		" Enable mouse usage (all modes)

" Source a global configuration file if available
if filereadable("/etc/vim/vimrc.local")
	source /etc/vim/vimrc.local
endif



"zs 注
"
"use: gg=:1,$ Enter 文件代码格式化

" 以下VIM配置,参考 pan.baidu.com 中的 zs_ubuntu压缩包中的;vim_ide文件夹

"常用变量
"$VIMRUNTIME
"$VIM : vim的安装的根目录.	[ad: ubuntu /usr/share/vim]


"zs config

"base config s
set tabstop=4
set softtabstop=4
set shiftwidth=4
set autoindent
set number
set wildmenu
set showcmd
set nobackup
"set bg=dark		"显示不同的底色色调
set wrap        "自动折行


" 设置编码
" set enc=utf-8
" " 设置文件编码
" set fenc=utf-8
" " 设置文件编码检测类型及支持格式
" set fencs=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
" " 指定菜单语言
" set langmenu=zh_CN.UTF-8
" "解决consle输出乱码
" language messages zh_CN.utf-8
" "解决菜单乱码
" source $VIMRUNTIME/delmenu.vim
" source $VIMRUNTIME/menu.vim
set fileencoding=utf8  "默认文件编码
set fileencodings==utf8,gbk,cp936  "可以识别的文件编码;需要Linux系统支持中文方可

"set guifont=Courier\\23		"在Linux种这样设置

" 中文帮助
" if version > 603
" set helplang=cn
" endif
"
"设置粘贴模式，这样粘贴过来的程序代码就不会错位了。zs注,很有用
"set paste


" 显示括号配对情况
set showmatch
" 自动缩进4空格
set cindent shiftwidth=4
" 智能自动缩进
set smartindent
" 设置自动缩进
set ai!

"set expandtab          "将tab替换为相应数量空格

"显示光标的状态行
set guioptions-=T
""隐藏左、右侧滚动条
set guioptions-=r
set guioptions-=L


" 单行注释
" set comments=://
" " 段落注释
" set comments=s1:/*,mb:*,ex0:/


"设置状态栏标尺
set ruler               "可显示最后一行的状态
set showmode            "左下角那一行的状态
"高亮显示当前行
set cursorline
"hi CursorLine cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
"高亮显示当前列
set cursorcolumn
"hi CursorColumn cterm=NONE ctermbg=darkred ctermfg=white guibg=darkred guifg=white
" cursor
"set cursorline
"hi CursorLine ctermbg=lightgray cterm=NONE
"set cursorcolumn
"hi CursorColumn ctermbg=lightgray
"
"base config e
"


"ext config s

"set mouse=a		" Enable mouse usage (all modes)

" 语法高亮
syntax enable
"开启文件类型侦测
syntax on
" 针对不同的文件类型采用不同的缩进格式
filetype indent on
" 针对不同的文件类型加载对应的插件
filetype plugin on
" 启用插件
filetype plugin indent on

" set cmdheight=1	" 设定命令行的行数为 1
set laststatus=2	" 显示状态栏 (默认值为 1, 无法显示状态栏)
" set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\%c:%l/%L%)\		" 设置在状态行显示的信息


"search config s
"输入搜索内容时就显示搜索结果
set incsearch
set nohls
"搜索结果高亮显示
set hlsearch
"用nh去掉查找后的高亮 zs注 :noh是vim的命令;可以参考这个配置来配置其它vim命令的快捷键
nmap nh :noh<cr>
set ofu=syntaxcomplete#Complete
"搜索时忽略大小写，但在有一个或以上大写字母时仍保持对大小写敏感
set ignorecase smartcase
"search config e


" vim 代码折叠设置 s

set fdm=indent
set autochdir				 " 自动切换当前目录为当前文件所在的目录

"set foldenable              " 开始折叠
"set foldmethod=syntax       " 设置语法折叠
"set foldcolumn=0            " 设置折叠区域的宽度
"setlocal foldlevel=1        " 设置折叠层数为
"set foldclose=all           " 设置为自动关闭折叠
"nnoremap <space> @=((foldclosed(line('.')) < 0) ? 'zc' : 'zo')<CR>		" 用空格键来开关折叠


" 打开javascript折叠
" javascript.vim 语法高亮
" ~/.vim/syntax/javascript.vim
let b:javascript_fold=1		"一般javascript编程，折叠层数不需要太深，我自己设置为1
" 打开javascript对dom、html和css的支持
let javascript_enable_domhtmlcss=1

" vim 代码折叠设置 e


"""""""
"return OS type, eg: windows, or linux, mac, et.st..
"function! MySys()
"	if has("win16") || has("win32") || has("win64") || has("win95")
"		return "windows"
"	elseif has("unix")
"		return "linux"
"	endif
"endfunction

" 用户目录变量$VIMFILES
"if MySys() == "windows"
"   let $VIMFILES = $VIM.'/vimfiles'
"elseif MySys() == "linux"
"   let $VIMFILES = $HOME.'/.vim'
"endif

"设定doc文档目录
"let helptags=$VIMFILES.'/doc'


""""""""""""""""""""'
"F2处理行尾的空格以及文件尾部的多余空行
"Automatically remove trailing spaces when saving a file.
autocmd BufRead,BufWrite * if ! &bin | silent! %s/\s\+$//ge | endif
"Remove indenting on empty line
map <F2> :w<CR>:call CleanupBuffer(1)<CR>:noh<CR>
function! CleanupBuffer(keep)
	" Skip binary files
	if (&bin > 0)
		return
	endif
	" Remove spaces and tabs from end of every line, if possible
	silent! %s/\s\+$//ge
	" Save current line number
	let lnum = line(".")
	" number of last line
	let lastline = line("$")
	let n        = lastline
	" while loop
	while (1)
		" content of last line
		let line = getline(n)
		" remove spaces and tab
		if (!empty(line))
			break
		endif
		let n = n - 1
	endwhile
	" Delete all empty lines at the end of file
	let start = n+1+a:keep
	if (start < lastline)
		execute n+1+a:keep . "," . lastline . "d"
	endif
	" after clean spaces and tabs, jump back
	exec "normal " . lnum . "G"
endfunction
""""""""""""""""""""'
"
"ext config e



" plugin config s

"color theme s
"一般的Linux发行版默认的终端都是16色的，但事实上几乎所有的终端都支持256色终端
"1.将Terminal设为Xterm模式:编辑->配置文件首选项->颜色
"设置为自定义,内置方案选择XTerm.
"2.vimrc里设置：set t_Co=256
"
"syntax enable
if has('gui_running')
	set background=light
else
	set background=dark
endif
set t_Co=16
colorscheme solarized
"set background=dark
"
"colorscheme desert
"color theme e

""""""

"javascript ide s
"
"javascript dict
autocmd FileType javascript set dictionary=~/.vim/dict/javascript.dict
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
":set omnifunc=javascriptcomplete#CompleteJS
"
"javascript ide e


"php ide s
"
"colorscheme peachpuff

"php缩进
let PHP_autoformatcomment=1
"
" Enable enhanced command line completion.
set wildmenu wildmode=list:full
" Ignore these filenames during enhanced command line completion.
set wildignore+=*.aux,*.out,*.toc " LaTeX intermediate files
set wildignore+=*.jpg,*.bmp,*.gif " binary images
set wildignore+=*.luac " Lua byte code
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest " compiled object files
set wildignore+=*.pyc " Python byte code
set wildignore+=*.spl " compiled spelling word lists
set wildignore+=*.sw? " Vim swap files
"
"
" You might also find this useful
" PHP Generated Code Highlights (HTML & SQL)
" let php_sql_query=1
" let php_htmlInStrings=1
" let g:php_folding=2
" set foldmethod=syntax
"
"
" syntax enable
" source ~/.vim/syntax/php.vim
"

"php complete|Autocomplete|vim php autocomplete s
"
"一、如何安装phpcomplete插件
"如果是VIM7.0以上，不需要再下载 phpcomplete.vim 这个插件，因为安装时自带了，在目录/usr/share/vim/vim73/autoload/phpcomplete.vim中。
""在 ~/.vimrc 中添加这样两行：
"filetype plugin on
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
set ofu=syntaxcomplete#Complete
"#只有在是PHP文件时，才启用PHP补全
"
"php complete e


"php 函数字典 s

"autocmd FileType php set dictionary+=~/.vim/php_funclist.dict
"autocmd FileType php set complete+=~/.vim/php_funclist.dict

"""""""""

"set dictionary-=/usr/share/vim/dict/php.dict dictionary+=/usr/share/vim/dict/php.dict
" 设置自动完成的监听方式：尾部添加一个字母和清除一个字母
"set complete-=k complete+=k

" 智能Tab补全的代码，它会根据上下文自动选择补全模式：
"inoremap <tab> <c-r>=Smart_TabComplete()<CR>
"function! Smart_TabComplete()
"  let line = getline('.')                         " current line
"
"  let substr = strpart(line, -1, col('.')+1)      " from the start of the current
"                                                  " line to one character right
"                                                  " of the cursor
"  let substr = matchstr(substr, "[^ \t]*$")       " word till cursor
"  if (strlen(substr)==0)                          " nothing to match on empty string
"    return "\<tab>"
"  endif
"  let has_period = match(substr, '\.') != -1      " position of period, if any
"  let has_slash = match(substr, '\/') != -1       " position of slash, if any
"  if (!has_period && !has_slash)
"    return "\<C-X>\<C-P>"                         " existing text matching
"  elseif ( has_slash )
"    return "\<C-X>\<C-F>"                         " file matching
"  else
"    return "\<C-X>\<C-O>"                         " plugin matching
"  endif
"endfunction

""""""""""

"设置字典自动完成
set complete+=k
"设置字典
set dictionary=~/.vim/php_funclist.dict
"" 自动完成使用TAB键
"This function determines, wether we are on
""the start of the line text(then tab indents)
"or if we want to try auto completion
function! InsertTabWrapper()
	let col=col('.')-1
	if !col || getline('.')[col-1] !~ '\k'
		return "\<TAB>"
	else
		return "\<C-N>"
	endif
endfunction
"使用SuperTab之后，就可以关闭该设置了
inoremap <TAB> <C-R>=InsertTabWrapper()<CR>

"php 函数字典 e


"php 中 一般是会在 "$", "->", "::" 后需要出现自动补全，在 .vimrc 中加入以下代码：
if !exists('g:AutoComplPop_Behavior')
	let g:AutoComplPop_Behavior = {}
	let g:AutoComplPop_Behavior['php'] = []
	call add(g:AutoComplPop_Behavior['php'], {
				\   'command'   : "\<C-x>\<C-o>",
				\   'pattern'   : printf('\(->\|::\|\$\)\k\{%d,}$', 0),
				\   'repeat'    : 0,
				\})
endif


"quickfix s

"quickfix s


"php documentor插件  s
"
"http://www.vim.org/scripts/script.php?script_id=1355
"下载php-doc.vim
"cp ./php-doc.vim /usr/share/vim/vim73/autoload/php-doc.vim
"
"如何使用：
"在函数定义出注释按ctrl+p即可
"
"source ~/.vim/php-doc.vim
"inoremap <C-P> <ESC>:call PhpDocSingle()<CR>i
"nnoremap <C-P> :call PhpDocSingle()<CR> 
"vnoremap <C-P> :call PhpDocRange()<CR>
"
"php documentor插件  e
" run file with PHP CLI (CTRL-M)
" :autocmd FileType php noremap <C-M> :w!<CR>:!/usr/bin/php %<CR>
"
" PHP parser check (CTRL-L)
" :autocmd FileType php noremap <C-L> :!/usr/bin/php -l %<CR>
"
" Do use the currently active spell checking for completion though!
" (I love this feature :-)
" set complete+=kspell


" PHP code sniffer s
" If code sniffer is installed you can run it on current php file by running
" :Phpcs
function! RunPhpcs()
	let l:filename=@%
	let l:phpcs_output=system('phpcs --report=csv --standard=YMC'.l:filename)
	"   echo l:phpcs_output
	let l:phpcs_list=split(l:phpcs_output, "\n")
	unlet l:phpcs_list[0]
	cexpr l:phpcs_list
	cwindow
endfunction

set errorformat+=\"%f\"\\,%l\\,%c\\,%t%*[a-zA-Z]\\,\"%m\"
"zs注:添加 Phpcs命令为Runphpcs()函数
command! Phpcs execute RunPhpcs()
"
" PHP code sniffer e


"Autocompletition s

"Autocompletition e

"php ide e


"html自动补全 s
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
"html自动补全 e

"html_autoclosetag.vim s
"html自动输入匹配标签，输入>之后自动完成匹配标签
"au FileType xhtml,xml so ~/.vim/ftplugin/html_autoclosetag.vim
"html_autoclosetag.vim e


"多文件编辑 s
""MiniBufExplorer
let g:miniBufExplMapCTabSwitchBufs=1
let g:miniBufExplMapWindowsNavVim=1
let g:miniBufExplMapWindowNavArrows=1
let g:miniBufExplModSelTarget = 1
let g:miniBufExplMapCTabSwitchWindows=1
let g:miniBufExplorerMoreThanOne=1
"多文件编辑 e
"Alt + -> 打开下一个文件
map <M-right> <ESC>:bn<RETURN>
"Alt + <- 打开上一个文件
map <M-left> <ESC>:bp<RETURN>


"NERDTree s
nmap <F3> :NERDTreeToggle<CR>		"F3快捷键
"let NERDTreeDirArrows=0
"NERDTree e


"neocomplcache s
let g:neocomplcache_enable_at_startup = 1
"neocomplcache e


"autocomplpop s
"自动补全插件

"autocomplpop e


"DoxygenToolkit s
"生成注释
"doxygen toolkit
let g:DoxygenToolkit_briefTag_pre="Function name "
"let g:DoxygenToolkit_briefTag_post = "<++>"
let g:DoxygenToolkit_paramTag_pre="@Param Param "
let g:DoxygenToolkit_returnTag="@Returns Returns"
"let g:DoxygenToolkit_blockHeader="--------------------------------------------------------------------------"
"let g:DoxygenToolkit_blockFooter="--------------------------------------------------------------------------"
let g:DoxygenToolkit_authorName="weiyan"
let g:DoxygenToolkit_licenseTag="license v"
let g:DoxygenToolkit_authorName="weiyan, weiyan@b5m.com"
let s:licenseTag = "Copyright(C)\<enter>"
let s:licenseTag = s:licenseTag . "For free\<enter>"
let s:licenseTag = s:licenseTag . "All right reserved\<enter>"
let g:DoxygenToolkit_licenseTag = s:licenseTag
let g:DoxygenToolkit_briefTag_funcName = "yes"
"let g:DoxygenToolkit_commentType= "php"
let g:DoxygenToolkit_compactDoc = "yes"
"let g:DoxygenToolkit_throwTag_pre = "yes"
let g:DoxygenToolkit_cinoptions = "no"
let g:doxygen_enhanced_color=1

"F1为添加文件头快捷键
"au FileType cpp map <F1> :DoxAuthor<CR>
"au FileType python map <F1> :DoxAuthor<CR>
"F2为添加函数注释
"au FileType cpp map <F2> :Dox<CR>
"au FileType python map <F2> :Dox<CR>

"" use doxygen 这个工具
"光标在函数上，用 :Dox 自动生成函数的说明
"光标在文件头，用 :DoxAuthor 自动生成文件说明
"用 :DoxLic
"可以结合doxygen自动生成各种格式的文档
"DoxygenToolkit e


" 状态栏颜色配置 s
if version >= 700
	au InsertEnter * hi StatusLine term=reverse ctermbg=5 gui=undercurl guisp=Magenta
	au InsertLeave * hi StatusLine term=reverse ctermfg=0 ctermbg=2 gui=bold,reverse
endif
"插入模式也有很多种派生的状态 s
function! InsertStatuslineColor(mode)
	if a:mode == 'i'
		hi statusline guibg=magenta
	elseif a:mode == 'r'
		hi statusline guibg=blue
	else
		hi statusline guibg=red
	endif
endfunction
au InsertEnter * call InsertStatuslineColor(v:insertmode)
au InsertChange * call InsertStatuslineColor(v:insertmode)
au InsertLeave * hi statusline guibg=green
" default the statusline to green when entering Vim
hi statusline guibg=green
"插入模式也有很多种派生的状态 e
" 状态栏颜色配置 e


"CTags s
"let Tlist_Ctags_Cmd="/usr/share/CTags"   "linux 下 ctags执行文件目录
let Tlist_Ctags_Cmd="/usr/bin/ctags"   "linux 下 ctags执行文件目录
"Taglist
""map <silent> <leader>tl :TlistToogle<cr>
let Tlist_Auto_Highlight_Tag = 1
let Tlist_Auto_Open = 1
let Tlist_Auto_Update = 1
let Tlist_Close_On_Select = 0
let Tlist_Compact_Format = 0
let Tlist_Display_Prototype = 0
let Tlist_Display_Tag_Scope = 1
let Tlist_Enable_Fold_Column = 0
let Tlist_Exit_OnlyWindow = 0
let Tlist_File_Fold_Auto_Close = 0
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Hightlight_Tag_On_BufEnter = 1
let Tlist_Inc_Winwidth = 0
let Tlist_Use_Right_Window = 1
"map <silent> <leader>tl :TlistToogle<cr>
map <F4> :TlistToggle<CR>		"F4快捷键
"CTags e

"Taglist s
"let Tlist_Ctags_Cmd="/usr/share/CTags"   "linux 下 ctags执行文件目录
let Tlist_Show_One_File = 1            "不同时显示多个文件的tag，只显示当前文件的
let Tlist_Exit_OnlyWindow = 1          "如果taglist窗口是最后一个窗口，则退出vim
let Tlist_Use_Right_Window = 1         "在右侧窗口中显示taglist窗口
"map <silent> <F9> :TlistToggle<cr>
"Taglist e
"
"Ctags 生成的tags文件路径
set tags=/var/www/html/zixun/tags
" 增强检索功能
"set tags=./tags,./../tags,./**/tags

"""""""""""""""""""""""
"F12生成/更新tags文件
set tags=tags;
set autochdir
function! UpdateTagsFile()
    silent !ctags -R --fields=+ianS --extra=+q
endfunction
nmap <F12> :call UpdateTagsFile()<CR>

"Ctrl + F12删除tags文件
function! DeleteTagsFile()
    "Linux下的删除方法
    "silent !rm tags
    "Windows下的删除方法
    silent !del /F /Q tags
endfunction
nmap <C-F12> :call DeleteTagsFile()<CR>
"退出VIM之前删除tags文件
"au VimLeavePre * call DeleteTagsFile()
"""""""""""""""""""""""
"
"zs use: Ctrl+] || Ctrl+t
"


"vim tab补全插件 s
"SuperTab.vim
"下载 supertab.vim
"sudo cp supertab.vmb /usr/share/vim/vim73/plugin/supertab.vim
"
"config s
"let g:SuperTabRetainCompletionType=2
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"

"以后当你准备按"Ctrl+X Ctrl+O"的时候直接按<Tab>就好了, 够爽吧 ....

"我稍微再介绍一下上面那两句配置信息:
"let g:SuperTabDefaultCompletionType="<C-X><C-O>"
" 设置按下<Tab>后默认的补全方式, 默认是<C-P>,
" " 现在改为<C-X><C-O>. 关于<C-P>的补全方式,
" " 还有其他的补全方式, 你可以看看下面的一些帮助:
" " :help ins-completion
" " :help compl-omni
"
" let g:SuperTabRetainCompletionType=2
" " 0 - 不记录上次的补全方式
" " 1 - 记住上次的补全方式,直到用其他的补全命令改变它
" " 2 - 记住上次的补全方式,直到按ESC退出插入模式为止
"config s
"
"
"""""""""""""""""""""""""""
"vim 中SuperTab的安装和使用
"『插件介绍』
"SuperTab使Tab快捷键具有更快捷的上下文提示功能。
"
"『下载和安装』
"从http://www.vim.org/scripts/script.php?script_id=1643下载安装版。这个安装包跟先前的几个Vim插件不同，它是一个vba文件，即Vimball格式的安装包，这种格式安装包提供傻瓜式的安装插件的方法。
"    1）用Vim打开.vba安装包文件。
"    2）在Vim命令行下运行命令“UseVimball ~/.vim”。此命令将安装包解压缩到~/.vim目录。VImball安装方式的便利之处在于你可以在任何目录打开.vba包安装，而不用切换到安装目的地目录。而且不用运行helptags命令安装帮助文档。
"    3）在~/.vimrc文件中加入以下这行：
"       let g:SuperTabDefaultCompletionType="context"
"
"      『基本功能使用方法』
"      SuperTab使用很简单，只要在输入变量名或路径名等符号中途按Tab键，就能得到以前输入过的符号列表，并通过Tab键循环选择。
"""""""""""""""""""""""""""
"
"vim tab补全插件 e



"snipMate s
"重启vim。
"如果还是不可以的话。可以在gvim任意打开一个文件，然后输入以下命令查看vim文件夹路径，并修改第3步中路径参数。
":echo $VIM                <<=================>>          D:/安装目录/Vim
":echo $VIMRUNTIME         <<=================>>	   	D:/安装目录/Vim/vim72
"(按tab快速生成代码段)
"
"let g:snippets_dir='$VIMRUNTIME/snippets'
"let g:snippets_dir='~/.vim/snipMate'
"
"
"////////////////////////////////
"打开vim分别输入以下几行命令
":echo $VIM
":ehco $VIMRUNTIME
":scriptname
"
"前两个会输出vim的路径,我这里的路径为
"/usr/shre/vim/
"/usr/shre/vim/vim73
"第三个会输出vim加载的脚本名,可以看到这里是没有加载/snipMate 的
"
"
"在 .vimrc里面添加配置
"set runtimepath=/usr/share/vim/vim73,~/vim,~/vim/after
"let g:snippets_dir='~/.vim/snippets'
"filetype plugin on
"
"snipMate e
"
"

" plugin config e


